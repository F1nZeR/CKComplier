//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g 2013-09-27 12:27:43

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019

#pragma warning disable 3021

using System.Text;

using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace CKCompiler.Analyzers
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class CKParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ASSIGN", "BoolTypeName", "CHAR", "CLASS", "COLON", "COMMA", "COMMENT", "CharTypeName", "Class", "ClassesList", "DIGIT", "DIV", "DOT", "ELSE", "ENDIF", "ENDLOOP", "EQUAL", "Expr", "Exprs", "FALL_THROUGH", "FALSE", "FLOAT", "FeatureList", "FloatTypeName", "FuncDef", "FunctionArgsList", "GE", "GT", "ID", "IF", "INTEGER", "ISVOID", "ImplicitInvoke", "IntTypeName", "InvokeExprs", "LCURLY", "LE", "LETTER", "LOOP", "LPAREN", "LT", "LocalOrFieldInit", "MINUS", "MULT", "MULTILINE_COMMENT", "NEG", "NEW", "NOT", "ObjectTypeName", "PLUS", "RCURLY", "RETURN", "RPAREN", "SEMI", "STRING", "StringTypeName", "THEN", "TRUE", "Term", "VAR", "VOID", "VarExprs", "WHILE", "WS"
	};
	public const int EOF=-1;
	public const int ASSIGN=4;
	public const int BoolTypeName=5;
	public const int CHAR=6;
	public const int CLASS=7;
	public const int COLON=8;
	public const int COMMA=9;
	public const int COMMENT=10;
	public const int CharTypeName=11;
	public const int Class=12;
	public const int ClassesList=13;
	public const int DIGIT=14;
	public const int DIV=15;
	public const int DOT=16;
	public const int ELSE=17;
	public const int ENDIF=18;
	public const int ENDLOOP=19;
	public const int EQUAL=20;
	public const int Expr=21;
	public const int Exprs=22;
	public const int FALL_THROUGH=23;
	public const int FALSE=24;
	public const int FLOAT=25;
	public const int FeatureList=26;
	public const int FloatTypeName=27;
	public const int FuncDef=28;
	public const int FunctionArgsList=29;
	public const int GE=30;
	public const int GT=31;
	public const int ID=32;
	public const int IF=33;
	public const int INTEGER=34;
	public const int ISVOID=35;
	public const int ImplicitInvoke=36;
	public const int IntTypeName=37;
	public const int InvokeExprs=38;
	public const int LCURLY=39;
	public const int LE=40;
	public const int LETTER=41;
	public const int LOOP=42;
	public const int LPAREN=43;
	public const int LT=44;
	public const int LocalOrFieldInit=45;
	public const int MINUS=46;
	public const int MULT=47;
	public const int MULTILINE_COMMENT=48;
	public const int NEG=49;
	public const int NEW=50;
	public const int NOT=51;
	public const int ObjectTypeName=52;
	public const int PLUS=53;
	public const int RCURLY=54;
	public const int RETURN=55;
	public const int RPAREN=56;
	public const int SEMI=57;
	public const int STRING=58;
	public const int StringTypeName=59;
	public const int THEN=60;
	public const int TRUE=61;
	public const int Term=62;
	public const int VAR=63;
	public const int VOID=64;
	public const int VarExprs=65;
	public const int WHILE=66;
	public const int WS=67;

	public CKParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public CKParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return CKParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();

	// $ANTLR start "program"
	// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:44:8: public program : ( classDef )+ -> ^( ClassesList ( classDef )+ ) ;
	[GrammarRule("program")]
	public AstParserRuleReturnScope<CommonTree, CommonToken> program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, CommonToken> classDef1 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		RewriteRuleSubtreeStream stream_classDef=new RewriteRuleSubtreeStream(adaptor,"rule classDef");
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(44, 40);
		try
		{
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:44:15: ( ( classDef )+ -> ^( ClassesList ( classDef )+ ) )
			DebugEnterAlt(1);
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:45:2: ( classDef )+
			{
			DebugLocation(45, 2);
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:45:2: ( classDef )+
			int cnt1=0;
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==CLASS))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:45:3: classDef
					{
					DebugLocation(45, 3);
					PushFollow(Follow._classDef_in_program146);
					classDef1=classDef();
					PopFollow();

					stream_classDef.Add(classDef1.Tree);

					}
					break;

				default:
					if (cnt1 >= 1)
						goto loop1;

					EarlyExitException eee1 = new EarlyExitException( 1, input );
					DebugRecognitionException(eee1);
					throw eee1;
				}
				cnt1++;
			}
			loop1:
				;

			} finally { DebugExitSubRule(1); }



			{
			// AST REWRITE
			// elements: classDef
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 45:14: -> ^( ClassesList ( classDef )+ )
			{
				DebugLocation(45, 17);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:45:17: ^( ClassesList ( classDef )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(45, 19);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ClassesList, "ClassesList"), root_1);

				DebugLocation(45, 31);
				if (!(stream_classDef.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_classDef.HasNext )
				{
					DebugLocation(45, 31);
					adaptor.AddChild(root_1, stream_classDef.NextTree());

				}
				stream_classDef.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(45, 40);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_classDef();
	partial void LeaveRule_classDef();

	// $ANTLR start "classDef"
	// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:47:1: classDef : CLASS typeName ( COLON typeName )? LCURLY featureList RCURLY -> ^( Class typeName featureList ( typeName )? ) ;
	[GrammarRule("classDef")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> classDef()
	{
		EnterRule_classDef();
		EnterRule("classDef", 2);
		TraceIn("classDef", 2);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken CLASS2 = default(CommonToken);
		CommonToken COLON4 = default(CommonToken);
		CommonToken LCURLY6 = default(CommonToken);
		CommonToken RCURLY8 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> typeName3 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> typeName5 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> featureList7 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree CLASS2_tree = default(CommonTree);
		CommonTree COLON4_tree = default(CommonTree);
		CommonTree LCURLY6_tree = default(CommonTree);
		CommonTree RCURLY8_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_CLASS=new RewriteRuleITokenStream(adaptor,"token CLASS");
		RewriteRuleITokenStream stream_LCURLY=new RewriteRuleITokenStream(adaptor,"token LCURLY");
		RewriteRuleITokenStream stream_RCURLY=new RewriteRuleITokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_typeName=new RewriteRuleSubtreeStream(adaptor,"rule typeName");
		RewriteRuleSubtreeStream stream_featureList=new RewriteRuleSubtreeStream(adaptor,"rule featureList");
		try { DebugEnterRule(GrammarFileName, "classDef");
		DebugLocation(47, 41);
		try
		{
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:47:9: ( CLASS typeName ( COLON typeName )? LCURLY featureList RCURLY -> ^( Class typeName featureList ( typeName )? ) )
			DebugEnterAlt(1);
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:48:2: CLASS typeName ( COLON typeName )? LCURLY featureList RCURLY
			{
			DebugLocation(48, 2);
			CLASS2=(CommonToken)Match(input,CLASS,Follow._CLASS_in_classDef167);  
			stream_CLASS.Add(CLASS2);

			DebugLocation(48, 8);
			PushFollow(Follow._typeName_in_classDef169);
			typeName3=typeName();
			PopFollow();

			stream_typeName.Add(typeName3.Tree);
			DebugLocation(48, 17);
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:48:17: ( COLON typeName )?
			int alt2=2;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, false);
			int LA2_0 = input.LA(1);

			if ((LA2_0==COLON))
			{
				alt2 = 1;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:48:18: COLON typeName
				{
				DebugLocation(48, 18);
				COLON4=(CommonToken)Match(input,COLON,Follow._COLON_in_classDef172);  
				stream_COLON.Add(COLON4);

				DebugLocation(48, 24);
				PushFollow(Follow._typeName_in_classDef174);
				typeName5=typeName();
				PopFollow();

				stream_typeName.Add(typeName5.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(2); }

			DebugLocation(48, 35);
			LCURLY6=(CommonToken)Match(input,LCURLY,Follow._LCURLY_in_classDef178);  
			stream_LCURLY.Add(LCURLY6);

			DebugLocation(48, 42);
			PushFollow(Follow._featureList_in_classDef180);
			featureList7=featureList();
			PopFollow();

			stream_featureList.Add(featureList7.Tree);
			DebugLocation(48, 54);
			RCURLY8=(CommonToken)Match(input,RCURLY,Follow._RCURLY_in_classDef182);  
			stream_RCURLY.Add(RCURLY8);



			{
			// AST REWRITE
			// elements: featureList, typeName, typeName
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 48:61: -> ^( Class typeName featureList ( typeName )? )
			{
				DebugLocation(49, 3);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:49:3: ^( Class typeName featureList ( typeName )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(49, 5);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Class, "Class"), root_1);

				DebugLocation(49, 11);
				adaptor.AddChild(root_1, stream_typeName.NextTree());
				DebugLocation(49, 20);
				adaptor.AddChild(root_1, stream_featureList.NextTree());
				DebugLocation(49, 32);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:49:32: ( typeName )?
				if (stream_typeName.HasNext)
				{
					DebugLocation(49, 32);
					adaptor.AddChild(root_1, stream_typeName.NextTree());

				}
				stream_typeName.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("classDef", 2);
			LeaveRule("classDef", 2);
			LeaveRule_classDef();
		}
		DebugLocation(49, 41);
		} finally { DebugExitRule(GrammarFileName, "classDef"); }
		return retval;

	}
	// $ANTLR end "classDef"

	partial void EnterRule_featureList();
	partial void LeaveRule_featureList();

	// $ANTLR start "featureList"
	// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:51:1: featureList : ( feature )* -> ^( FeatureList ( feature )* ) ;
	[GrammarRule("featureList")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> featureList()
	{
		EnterRule_featureList();
		EnterRule("featureList", 3);
		TraceIn("featureList", 3);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, CommonToken> feature9 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		RewriteRuleSubtreeStream stream_feature=new RewriteRuleSubtreeStream(adaptor,"rule feature");
		try { DebugEnterRule(GrammarFileName, "featureList");
		DebugLocation(51, 38);
		try
		{
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:51:12: ( ( feature )* -> ^( FeatureList ( feature )* ) )
			DebugEnterAlt(1);
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:52:2: ( feature )*
			{
			DebugLocation(52, 2);
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:52:2: ( feature )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_0 = input.LA(1);

				if ((LA3_0==ID))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:52:3: feature
					{
					DebugLocation(52, 3);
					PushFollow(Follow._feature_in_featureList208);
					feature9=feature();
					PopFollow();

					stream_feature.Add(feature9.Tree);

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }



			{
			// AST REWRITE
			// elements: feature
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 52:13: -> ^( FeatureList ( feature )* )
			{
				DebugLocation(52, 16);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:52:16: ^( FeatureList ( feature )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(52, 18);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FeatureList, "FeatureList"), root_1);

				DebugLocation(52, 30);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:52:30: ( feature )*
				while ( stream_feature.HasNext )
				{
					DebugLocation(52, 30);
					adaptor.AddChild(root_1, stream_feature.NextTree());

				}
				stream_feature.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("featureList", 3);
			LeaveRule("featureList", 3);
			LeaveRule_featureList();
		}
		DebugLocation(52, 38);
		} finally { DebugExitRule(GrammarFileName, "featureList"); }
		return retval;

	}
	// $ANTLR end "featureList"

	partial void EnterRule_feature();
	partial void LeaveRule_feature();

	// $ANTLR start "feature"
	// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:54:1: feature : ( ( ID LPAREN ( formalList )? RPAREN COLON typeName LCURLY expr RCURLY ) -> ^( FuncDef ID typeName expr ( formalList )? ) | localOrFieldInit );
	[GrammarRule("feature")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> feature()
	{
		EnterRule_feature();
		EnterRule("feature", 4);
		TraceIn("feature", 4);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken ID10 = default(CommonToken);
		CommonToken LPAREN11 = default(CommonToken);
		CommonToken RPAREN13 = default(CommonToken);
		CommonToken COLON14 = default(CommonToken);
		CommonToken LCURLY16 = default(CommonToken);
		CommonToken RCURLY18 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> formalList12 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> typeName15 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr17 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> localOrFieldInit19 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree ID10_tree = default(CommonTree);
		CommonTree LPAREN11_tree = default(CommonTree);
		CommonTree RPAREN13_tree = default(CommonTree);
		CommonTree COLON14_tree = default(CommonTree);
		CommonTree LCURLY16_tree = default(CommonTree);
		CommonTree RCURLY18_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_LCURLY=new RewriteRuleITokenStream(adaptor,"token LCURLY");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RCURLY=new RewriteRuleITokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_typeName=new RewriteRuleSubtreeStream(adaptor,"rule typeName");
		RewriteRuleSubtreeStream stream_formalList=new RewriteRuleSubtreeStream(adaptor,"rule formalList");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "feature");
		DebugLocation(54, 22);
		try
		{
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:54:8: ( ( ID LPAREN ( formalList )? RPAREN COLON typeName LCURLY expr RCURLY ) -> ^( FuncDef ID typeName expr ( formalList )? ) | localOrFieldInit )
			int alt5=2;
			try { DebugEnterDecision(5, false);
			int LA5_0 = input.LA(1);

			if ((LA5_0==ID))
			{
				int LA5_1 = input.LA(2);

				if ((LA5_1==LPAREN))
				{
					alt5 = 1;
				}
				else if ((LA5_1==COLON))
				{
					alt5 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 5, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 5, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:55:3: ( ID LPAREN ( formalList )? RPAREN COLON typeName LCURLY expr RCURLY )
				{
				DebugLocation(55, 3);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:55:3: ( ID LPAREN ( formalList )? RPAREN COLON typeName LCURLY expr RCURLY )
				DebugEnterAlt(1);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:55:4: ID LPAREN ( formalList )? RPAREN COLON typeName LCURLY expr RCURLY
				{
				DebugLocation(55, 4);
				ID10=(CommonToken)Match(input,ID,Follow._ID_in_feature231);  
				stream_ID.Add(ID10);

				DebugLocation(55, 7);
				LPAREN11=(CommonToken)Match(input,LPAREN,Follow._LPAREN_in_feature233);  
				stream_LPAREN.Add(LPAREN11);

				DebugLocation(55, 14);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:55:14: ( formalList )?
				int alt4=2;
				try { DebugEnterSubRule(4);
				try { DebugEnterDecision(4, false);
				int LA4_0 = input.LA(1);

				if ((LA4_0==ID))
				{
					alt4 = 1;
				}
				} finally { DebugExitDecision(4); }
				switch (alt4)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:55:15: formalList
					{
					DebugLocation(55, 15);
					PushFollow(Follow._formalList_in_feature236);
					formalList12=formalList();
					PopFollow();

					stream_formalList.Add(formalList12.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(4); }

				DebugLocation(55, 28);
				RPAREN13=(CommonToken)Match(input,RPAREN,Follow._RPAREN_in_feature240);  
				stream_RPAREN.Add(RPAREN13);

				DebugLocation(55, 35);
				COLON14=(CommonToken)Match(input,COLON,Follow._COLON_in_feature242);  
				stream_COLON.Add(COLON14);

				DebugLocation(55, 41);
				PushFollow(Follow._typeName_in_feature244);
				typeName15=typeName();
				PopFollow();

				stream_typeName.Add(typeName15.Tree);
				DebugLocation(55, 50);
				LCURLY16=(CommonToken)Match(input,LCURLY,Follow._LCURLY_in_feature246);  
				stream_LCURLY.Add(LCURLY16);

				DebugLocation(55, 57);
				PushFollow(Follow._expr_in_feature248);
				expr17=expr();
				PopFollow();

				stream_expr.Add(expr17.Tree);
				DebugLocation(55, 62);
				RCURLY18=(CommonToken)Match(input,RCURLY,Follow._RCURLY_in_feature250);  
				stream_RCURLY.Add(RCURLY18);


				}



				{
				// AST REWRITE
				// elements: expr, ID, typeName, formalList
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 55:70: -> ^( FuncDef ID typeName expr ( formalList )? )
				{
					DebugLocation(56, 4);
					// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:56:4: ^( FuncDef ID typeName expr ( formalList )? )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(56, 6);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FuncDef, "FuncDef"), root_1);

					DebugLocation(56, 14);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(56, 17);
					adaptor.AddChild(root_1, stream_typeName.NextTree());
					DebugLocation(56, 26);
					adaptor.AddChild(root_1, stream_expr.NextTree());
					DebugLocation(56, 31);
					// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:56:31: ( formalList )?
					if (stream_formalList.HasNext)
					{
						DebugLocation(56, 31);
						adaptor.AddChild(root_1, stream_formalList.NextTree());

					}
					stream_formalList.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:57:6: localOrFieldInit
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(57, 6);
				PushFollow(Follow._localOrFieldInit_in_feature277);
				localOrFieldInit19=localOrFieldInit();
				PopFollow();

				adaptor.AddChild(root_0, localOrFieldInit19.Tree);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("feature", 4);
			LeaveRule("feature", 4);
			LeaveRule_feature();
		}
		DebugLocation(57, 22);
		} finally { DebugExitRule(GrammarFileName, "feature"); }
		return retval;

	}
	// $ANTLR end "feature"

	partial void EnterRule_formalList();
	partial void LeaveRule_formalList();

	// $ANTLR start "formalList"
	// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:59:1: formalList : formal ( COMMA formal )* -> ^( FunctionArgsList ( formal )+ ) ;
	[GrammarRule("formalList")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> formalList()
	{
		EnterRule_formalList();
		EnterRule("formalList", 5);
		TraceIn("formalList", 5);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken COMMA21 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> formal20 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> formal22 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree COMMA21_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_formal=new RewriteRuleSubtreeStream(adaptor,"rule formal");
		try { DebugEnterRule(GrammarFileName, "formalList");
		DebugLocation(59, 54);
		try
		{
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:59:11: ( formal ( COMMA formal )* -> ^( FunctionArgsList ( formal )+ ) )
			DebugEnterAlt(1);
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:60:2: formal ( COMMA formal )*
			{
			DebugLocation(60, 2);
			PushFollow(Follow._formal_in_formalList286);
			formal20=formal();
			PopFollow();

			stream_formal.Add(formal20.Tree);
			DebugLocation(60, 9);
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:60:9: ( COMMA formal )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_0 = input.LA(1);

				if ((LA6_0==COMMA))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:60:10: COMMA formal
					{
					DebugLocation(60, 10);
					COMMA21=(CommonToken)Match(input,COMMA,Follow._COMMA_in_formalList289);  
					stream_COMMA.Add(COMMA21);

					DebugLocation(60, 16);
					PushFollow(Follow._formal_in_formalList291);
					formal22=formal();
					PopFollow();

					stream_formal.Add(formal22.Tree);

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }



			{
			// AST REWRITE
			// elements: formal
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 60:25: -> ^( FunctionArgsList ( formal )+ )
			{
				DebugLocation(60, 28);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:60:28: ^( FunctionArgsList ( formal )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(60, 30);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FunctionArgsList, "FunctionArgsList"), root_1);

				DebugLocation(60, 47);
				if (!(stream_formal.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_formal.HasNext )
				{
					DebugLocation(60, 47);
					adaptor.AddChild(root_1, stream_formal.NextTree());

				}
				stream_formal.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("formalList", 5);
			LeaveRule("formalList", 5);
			LeaveRule_formalList();
		}
		DebugLocation(60, 54);
		} finally { DebugExitRule(GrammarFileName, "formalList"); }
		return retval;

	}
	// $ANTLR end "formalList"

	partial void EnterRule_formal();
	partial void LeaveRule_formal();

	// $ANTLR start "formal"
	// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:62:1: formal : ID COLON ^ typeName ;
	[GrammarRule("formal")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> formal()
	{
		EnterRule_formal();
		EnterRule("formal", 6);
		TraceIn("formal", 6);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken ID23 = default(CommonToken);
		CommonToken COLON24 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> typeName25 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree ID23_tree = default(CommonTree);
		CommonTree COLON24_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "formal");
		DebugLocation(62, 26);
		try
		{
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:62:7: ( ID COLON ^ typeName )
			DebugEnterAlt(1);
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:62:9: ID COLON ^ typeName
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(62, 9);
			ID23=(CommonToken)Match(input,ID,Follow._ID_in_formal309); 
			ID23_tree = (CommonTree)adaptor.Create(ID23);
			adaptor.AddChild(root_0, ID23_tree);
			DebugLocation(62, 17);
			COLON24=(CommonToken)Match(input,COLON,Follow._COLON_in_formal311); 
			COLON24_tree = (CommonTree)adaptor.Create(COLON24);
			root_0 = (CommonTree)adaptor.BecomeRoot(COLON24_tree, root_0);
			DebugLocation(62, 19);
			PushFollow(Follow._typeName_in_formal314);
			typeName25=typeName();
			PopFollow();

			adaptor.AddChild(root_0, typeName25.Tree);

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("formal", 6);
			LeaveRule("formal", 6);
			LeaveRule_formal();
		}
		DebugLocation(62, 26);
		} finally { DebugExitRule(GrammarFileName, "formal"); }
		return retval;

	}
	// $ANTLR end "formal"

	partial void EnterRule_expr();
	partial void LeaveRule_expr();

	// $ANTLR start "expr"
	// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:64:1: expr : ( ID ASSIGN ^)* not ;
	[GrammarRule("expr")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> expr()
	{
		EnterRule_expr();
		EnterRule("expr", 7);
		TraceIn("expr", 7);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken ID26 = default(CommonToken);
		CommonToken ASSIGN27 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> not28 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree ID26_tree = default(CommonTree);
		CommonTree ASSIGN27_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(64, 18);
		try
		{
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:64:5: ( ( ID ASSIGN ^)* not )
			DebugEnterAlt(1);
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:65:2: ( ID ASSIGN ^)* not
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(65, 2);
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:65:2: ( ID ASSIGN ^)*
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				int LA7_0 = input.LA(1);

				if ((LA7_0==ID))
				{
					int LA7_2 = input.LA(2);

					if ((LA7_2==ASSIGN))
					{
						alt7 = 1;
					}


				}


				} finally { DebugExitDecision(7); }
				switch ( alt7 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:65:3: ID ASSIGN ^
					{
					DebugLocation(65, 3);
					ID26=(CommonToken)Match(input,ID,Follow._ID_in_expr323); 
					ID26_tree = (CommonTree)adaptor.Create(ID26);
					adaptor.AddChild(root_0, ID26_tree);
					DebugLocation(65, 12);
					ASSIGN27=(CommonToken)Match(input,ASSIGN,Follow._ASSIGN_in_expr325); 
					ASSIGN27_tree = (CommonTree)adaptor.Create(ASSIGN27);
					root_0 = (CommonTree)adaptor.BecomeRoot(ASSIGN27_tree, root_0);

					}
					break;

				default:
					goto loop7;
				}
			}

			loop7:
				;

			} finally { DebugExitSubRule(7); }

			DebugLocation(65, 16);
			PushFollow(Follow._not_in_expr330);
			not28=not();
			PopFollow();

			adaptor.AddChild(root_0, not28.Tree);

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("expr", 7);
			LeaveRule("expr", 7);
			LeaveRule_expr();
		}
		DebugLocation(65, 18);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return retval;

	}
	// $ANTLR end "expr"

	partial void EnterRule_not();
	partial void LeaveRule_not();

	// $ANTLR start "not"
	// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:67:1: not : ( NOT ^)* relation ;
	[GrammarRule("not")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> not()
	{
		EnterRule_not();
		EnterRule("not", 8);
		TraceIn("not", 8);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken NOT29 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> relation30 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree NOT29_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "not");
		DebugLocation(67, 17);
		try
		{
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:67:4: ( ( NOT ^)* relation )
			DebugEnterAlt(1);
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:68:2: ( NOT ^)* relation
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(68, 2);
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:68:2: ( NOT ^)*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_0 = input.LA(1);

				if ((LA8_0==NOT))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:68:3: NOT ^
					{
					DebugLocation(68, 6);
					NOT29=(CommonToken)Match(input,NOT,Follow._NOT_in_not341); 
					NOT29_tree = (CommonTree)adaptor.Create(NOT29);
					root_0 = (CommonTree)adaptor.BecomeRoot(NOT29_tree, root_0);

					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }

			DebugLocation(68, 10);
			PushFollow(Follow._relation_in_not346);
			relation30=relation();
			PopFollow();

			adaptor.AddChild(root_0, relation30.Tree);

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("not", 8);
			LeaveRule("not", 8);
			LeaveRule_not();
		}
		DebugLocation(68, 17);
		} finally { DebugExitRule(GrammarFileName, "not"); }
		return retval;

	}
	// $ANTLR end "not"

	partial void EnterRule_relation();
	partial void LeaveRule_relation();

	// $ANTLR start "relation"
	// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:70:1: relation : addition ( ( LE ^| LT ^| GE ^| GT ^| EQUAL ^) addition )* ;
	[GrammarRule("relation")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> relation()
	{
		EnterRule_relation();
		EnterRule("relation", 9);
		TraceIn("relation", 9);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken LE32 = default(CommonToken);
		CommonToken LT33 = default(CommonToken);
		CommonToken GE34 = default(CommonToken);
		CommonToken GT35 = default(CommonToken);
		CommonToken EQUAL36 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> addition31 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> addition37 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree LE32_tree = default(CommonTree);
		CommonTree LT33_tree = default(CommonTree);
		CommonTree GE34_tree = default(CommonTree);
		CommonTree GT35_tree = default(CommonTree);
		CommonTree EQUAL36_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "relation");
		DebugLocation(70, 54);
		try
		{
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:70:9: ( addition ( ( LE ^| LT ^| GE ^| GT ^| EQUAL ^) addition )* )
			DebugEnterAlt(1);
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:71:2: addition ( ( LE ^| LT ^| GE ^| GT ^| EQUAL ^) addition )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(71, 2);
			PushFollow(Follow._addition_in_relation355);
			addition31=addition();
			PopFollow();

			adaptor.AddChild(root_0, addition31.Tree);
			DebugLocation(71, 11);
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:71:11: ( ( LE ^| LT ^| GE ^| GT ^| EQUAL ^) addition )*
			try { DebugEnterSubRule(10);
			while (true)
			{
				int alt10=2;
				try { DebugEnterDecision(10, false);
				switch (input.LA(1))
				{
				case LE:
					{
					alt10 = 1;
					}
					break;
				case LT:
					{
					alt10 = 1;
					}
					break;
				case GE:
					{
					alt10 = 1;
					}
					break;
				case GT:
					{
					alt10 = 1;
					}
					break;
				case EQUAL:
					{
					alt10 = 1;
					}
					break;
				}

				} finally { DebugExitDecision(10); }
				switch ( alt10 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:71:12: ( LE ^| LT ^| GE ^| GT ^| EQUAL ^) addition
					{
					DebugLocation(71, 12);
					// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:71:12: ( LE ^| LT ^| GE ^| GT ^| EQUAL ^)
					int alt9=5;
					try { DebugEnterSubRule(9);
					try { DebugEnterDecision(9, false);
					switch (input.LA(1))
					{
					case LE:
						{
						alt9 = 1;
						}
						break;
					case LT:
						{
						alt9 = 2;
						}
						break;
					case GE:
						{
						alt9 = 3;
						}
						break;
					case GT:
						{
						alt9 = 4;
						}
						break;
					case EQUAL:
						{
						alt9 = 5;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 9, 0, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(9); }
					switch (alt9)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:71:13: LE ^
						{
						DebugLocation(71, 15);
						LE32=(CommonToken)Match(input,LE,Follow._LE_in_relation359); 
						LE32_tree = (CommonTree)adaptor.Create(LE32);
						root_0 = (CommonTree)adaptor.BecomeRoot(LE32_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:71:19: LT ^
						{
						DebugLocation(71, 21);
						LT33=(CommonToken)Match(input,LT,Follow._LT_in_relation364); 
						LT33_tree = (CommonTree)adaptor.Create(LT33);
						root_0 = (CommonTree)adaptor.BecomeRoot(LT33_tree, root_0);

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:71:25: GE ^
						{
						DebugLocation(71, 27);
						GE34=(CommonToken)Match(input,GE,Follow._GE_in_relation369); 
						GE34_tree = (CommonTree)adaptor.Create(GE34);
						root_0 = (CommonTree)adaptor.BecomeRoot(GE34_tree, root_0);

						}
						break;
					case 4:
						DebugEnterAlt(4);
						// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:71:31: GT ^
						{
						DebugLocation(71, 33);
						GT35=(CommonToken)Match(input,GT,Follow._GT_in_relation374); 
						GT35_tree = (CommonTree)adaptor.Create(GT35);
						root_0 = (CommonTree)adaptor.BecomeRoot(GT35_tree, root_0);

						}
						break;
					case 5:
						DebugEnterAlt(5);
						// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:71:37: EQUAL ^
						{
						DebugLocation(71, 42);
						EQUAL36=(CommonToken)Match(input,EQUAL,Follow._EQUAL_in_relation379); 
						EQUAL36_tree = (CommonTree)adaptor.Create(EQUAL36);
						root_0 = (CommonTree)adaptor.BecomeRoot(EQUAL36_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(9); }

					DebugLocation(71, 45);
					PushFollow(Follow._addition_in_relation383);
					addition37=addition();
					PopFollow();

					adaptor.AddChild(root_0, addition37.Tree);

					}
					break;

				default:
					goto loop10;
				}
			}

			loop10:
				;

			} finally { DebugExitSubRule(10); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("relation", 9);
			LeaveRule("relation", 9);
			LeaveRule_relation();
		}
		DebugLocation(71, 54);
		} finally { DebugExitRule(GrammarFileName, "relation"); }
		return retval;

	}
	// $ANTLR end "relation"

	partial void EnterRule_addition();
	partial void LeaveRule_addition();

	// $ANTLR start "addition"
	// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:73:1: addition : multiplication ( ( PLUS ^| MINUS ^) multiplication )* ;
	[GrammarRule("addition")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> addition()
	{
		EnterRule_addition();
		EnterRule("addition", 10);
		TraceIn("addition", 10);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken PLUS39 = default(CommonToken);
		CommonToken MINUS40 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> multiplication38 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> multiplication41 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree PLUS39_tree = default(CommonTree);
		CommonTree MINUS40_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "addition");
		DebugLocation(73, 50);
		try
		{
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:73:9: ( multiplication ( ( PLUS ^| MINUS ^) multiplication )* )
			DebugEnterAlt(1);
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:74:2: multiplication ( ( PLUS ^| MINUS ^) multiplication )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(74, 2);
			PushFollow(Follow._multiplication_in_addition394);
			multiplication38=multiplication();
			PopFollow();

			adaptor.AddChild(root_0, multiplication38.Tree);
			DebugLocation(74, 17);
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:74:17: ( ( PLUS ^| MINUS ^) multiplication )*
			try { DebugEnterSubRule(12);
			while (true)
			{
				int alt12=2;
				try { DebugEnterDecision(12, false);
				int LA12_0 = input.LA(1);

				if ((LA12_0==PLUS))
				{
					alt12 = 1;
				}
				else if ((LA12_0==MINUS))
				{
					alt12 = 1;
				}


				} finally { DebugExitDecision(12); }
				switch ( alt12 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:74:18: ( PLUS ^| MINUS ^) multiplication
					{
					DebugLocation(74, 18);
					// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:74:18: ( PLUS ^| MINUS ^)
					int alt11=2;
					try { DebugEnterSubRule(11);
					try { DebugEnterDecision(11, false);
					int LA11_0 = input.LA(1);

					if ((LA11_0==PLUS))
					{
						alt11 = 1;
					}
					else if ((LA11_0==MINUS))
					{
						alt11 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 11, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(11); }
					switch (alt11)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:74:19: PLUS ^
						{
						DebugLocation(74, 23);
						PLUS39=(CommonToken)Match(input,PLUS,Follow._PLUS_in_addition398); 
						PLUS39_tree = (CommonTree)adaptor.Create(PLUS39);
						root_0 = (CommonTree)adaptor.BecomeRoot(PLUS39_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:74:27: MINUS ^
						{
						DebugLocation(74, 32);
						MINUS40=(CommonToken)Match(input,MINUS,Follow._MINUS_in_addition403); 
						MINUS40_tree = (CommonTree)adaptor.Create(MINUS40);
						root_0 = (CommonTree)adaptor.BecomeRoot(MINUS40_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(11); }

					DebugLocation(74, 35);
					PushFollow(Follow._multiplication_in_addition407);
					multiplication41=multiplication();
					PopFollow();

					adaptor.AddChild(root_0, multiplication41.Tree);

					}
					break;

				default:
					goto loop12;
				}
			}

			loop12:
				;

			} finally { DebugExitSubRule(12); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("addition", 10);
			LeaveRule("addition", 10);
			LeaveRule_addition();
		}
		DebugLocation(74, 50);
		} finally { DebugExitRule(GrammarFileName, "addition"); }
		return retval;

	}
	// $ANTLR end "addition"

	partial void EnterRule_multiplication();
	partial void LeaveRule_multiplication();

	// $ANTLR start "multiplication"
	// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:76:1: multiplication : isvoid ( ( MULT ^| DIV ^) isvoid )* ;
	[GrammarRule("multiplication")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> multiplication()
	{
		EnterRule_multiplication();
		EnterRule("multiplication", 11);
		TraceIn("multiplication", 11);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken MULT43 = default(CommonToken);
		CommonToken DIV44 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> isvoid42 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> isvoid45 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree MULT43_tree = default(CommonTree);
		CommonTree DIV44_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "multiplication");
		DebugLocation(76, 32);
		try
		{
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:76:15: ( isvoid ( ( MULT ^| DIV ^) isvoid )* )
			DebugEnterAlt(1);
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:77:2: isvoid ( ( MULT ^| DIV ^) isvoid )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(77, 2);
			PushFollow(Follow._isvoid_in_multiplication417);
			isvoid42=isvoid();
			PopFollow();

			adaptor.AddChild(root_0, isvoid42.Tree);
			DebugLocation(77, 9);
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:77:9: ( ( MULT ^| DIV ^) isvoid )*
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=2;
				try { DebugEnterDecision(14, false);
				int LA14_0 = input.LA(1);

				if ((LA14_0==MULT))
				{
					alt14 = 1;
				}
				else if ((LA14_0==DIV))
				{
					alt14 = 1;
				}


				} finally { DebugExitDecision(14); }
				switch ( alt14 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:77:10: ( MULT ^| DIV ^) isvoid
					{
					DebugLocation(77, 10);
					// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:77:10: ( MULT ^| DIV ^)
					int alt13=2;
					try { DebugEnterSubRule(13);
					try { DebugEnterDecision(13, false);
					int LA13_0 = input.LA(1);

					if ((LA13_0==MULT))
					{
						alt13 = 1;
					}
					else if ((LA13_0==DIV))
					{
						alt13 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 13, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(13); }
					switch (alt13)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:77:11: MULT ^
						{
						DebugLocation(77, 15);
						MULT43=(CommonToken)Match(input,MULT,Follow._MULT_in_multiplication421); 
						MULT43_tree = (CommonTree)adaptor.Create(MULT43);
						root_0 = (CommonTree)adaptor.BecomeRoot(MULT43_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:77:19: DIV ^
						{
						DebugLocation(77, 22);
						DIV44=(CommonToken)Match(input,DIV,Follow._DIV_in_multiplication426); 
						DIV44_tree = (CommonTree)adaptor.Create(DIV44);
						root_0 = (CommonTree)adaptor.BecomeRoot(DIV44_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(13); }

					DebugLocation(77, 25);
					PushFollow(Follow._isvoid_in_multiplication430);
					isvoid45=isvoid();
					PopFollow();

					adaptor.AddChild(root_0, isvoid45.Tree);

					}
					break;

				default:
					goto loop14;
				}
			}

			loop14:
				;

			} finally { DebugExitSubRule(14); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("multiplication", 11);
			LeaveRule("multiplication", 11);
			LeaveRule_multiplication();
		}
		DebugLocation(77, 32);
		} finally { DebugExitRule(GrammarFileName, "multiplication"); }
		return retval;

	}
	// $ANTLR end "multiplication"

	partial void EnterRule_isvoid();
	partial void LeaveRule_isvoid();

	// $ANTLR start "isvoid"
	// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:79:1: isvoid : ( ISVOID ^)* neg ;
	[GrammarRule("isvoid")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> isvoid()
	{
		EnterRule_isvoid();
		EnterRule("isvoid", 12);
		TraceIn("isvoid", 12);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken ISVOID46 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> neg47 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree ISVOID46_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "isvoid");
		DebugLocation(79, 15);
		try
		{
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:79:7: ( ( ISVOID ^)* neg )
			DebugEnterAlt(1);
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:80:2: ( ISVOID ^)* neg
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(80, 2);
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:80:2: ( ISVOID ^)*
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=2;
				try { DebugEnterDecision(15, false);
				int LA15_0 = input.LA(1);

				if ((LA15_0==ISVOID))
				{
					alt15 = 1;
				}


				} finally { DebugExitDecision(15); }
				switch ( alt15 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:80:3: ISVOID ^
					{
					DebugLocation(80, 9);
					ISVOID46=(CommonToken)Match(input,ISVOID,Follow._ISVOID_in_isvoid441); 
					ISVOID46_tree = (CommonTree)adaptor.Create(ISVOID46);
					root_0 = (CommonTree)adaptor.BecomeRoot(ISVOID46_tree, root_0);

					}
					break;

				default:
					goto loop15;
				}
			}

			loop15:
				;

			} finally { DebugExitSubRule(15); }

			DebugLocation(80, 13);
			PushFollow(Follow._neg_in_isvoid446);
			neg47=neg();
			PopFollow();

			adaptor.AddChild(root_0, neg47.Tree);

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("isvoid", 12);
			LeaveRule("isvoid", 12);
			LeaveRule_isvoid();
		}
		DebugLocation(80, 15);
		} finally { DebugExitRule(GrammarFileName, "isvoid"); }
		return retval;

	}
	// $ANTLR end "isvoid"

	partial void EnterRule_neg();
	partial void LeaveRule_neg();

	// $ANTLR start "neg"
	// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:82:1: neg : ( NEG ^)* dot ;
	[GrammarRule("neg")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> neg()
	{
		EnterRule_neg();
		EnterRule("neg", 13);
		TraceIn("neg", 13);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken NEG48 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> dot49 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree NEG48_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "neg");
		DebugLocation(82, 12);
		try
		{
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:82:4: ( ( NEG ^)* dot )
			DebugEnterAlt(1);
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:83:2: ( NEG ^)* dot
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(83, 2);
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:83:2: ( NEG ^)*
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=2;
				try { DebugEnterDecision(16, false);
				int LA16_0 = input.LA(1);

				if ((LA16_0==NEG))
				{
					alt16 = 1;
				}


				} finally { DebugExitDecision(16); }
				switch ( alt16 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:83:3: NEG ^
					{
					DebugLocation(83, 6);
					NEG48=(CommonToken)Match(input,NEG,Follow._NEG_in_neg455); 
					NEG48_tree = (CommonTree)adaptor.Create(NEG48);
					root_0 = (CommonTree)adaptor.BecomeRoot(NEG48_tree, root_0);

					}
					break;

				default:
					goto loop16;
				}
			}

			loop16:
				;

			} finally { DebugExitSubRule(16); }

			DebugLocation(83, 10);
			PushFollow(Follow._dot_in_neg460);
			dot49=dot();
			PopFollow();

			adaptor.AddChild(root_0, dot49.Tree);

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("neg", 13);
			LeaveRule("neg", 13);
			LeaveRule_neg();
		}
		DebugLocation(83, 12);
		} finally { DebugExitRule(GrammarFileName, "neg"); }
		return retval;

	}
	// $ANTLR end "neg"

	partial void EnterRule_dot();
	partial void LeaveRule_dot();

	// $ANTLR start "dot"
	// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:85:1: dot : term ( DOT ID LPAREN ( invokeExprs )? RPAREN )? -> ^( Term term ( ID )? ( invokeExprs )? ) ;
	[GrammarRule("dot")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> dot()
	{
		EnterRule_dot();
		EnterRule("dot", 14);
		TraceIn("dot", 14);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken DOT51 = default(CommonToken);
		CommonToken ID52 = default(CommonToken);
		CommonToken LPAREN53 = default(CommonToken);
		CommonToken RPAREN55 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> term50 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> invokeExprs54 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree DOT51_tree = default(CommonTree);
		CommonTree ID52_tree = default(CommonTree);
		CommonTree LPAREN53_tree = default(CommonTree);
		CommonTree RPAREN55_tree = default(CommonTree);
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_DOT=new RewriteRuleITokenStream(adaptor,"token DOT");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleSubtreeStream stream_term=new RewriteRuleSubtreeStream(adaptor,"rule term");
		RewriteRuleSubtreeStream stream_invokeExprs=new RewriteRuleSubtreeStream(adaptor,"rule invokeExprs");
		try { DebugEnterRule(GrammarFileName, "dot");
		DebugLocation(85, 31);
		try
		{
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:85:4: ( term ( DOT ID LPAREN ( invokeExprs )? RPAREN )? -> ^( Term term ( ID )? ( invokeExprs )? ) )
			DebugEnterAlt(1);
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:86:2: term ( DOT ID LPAREN ( invokeExprs )? RPAREN )?
			{
			DebugLocation(86, 2);
			PushFollow(Follow._term_in_dot469);
			term50=term();
			PopFollow();

			stream_term.Add(term50.Tree);
			DebugLocation(86, 7);
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:86:7: ( DOT ID LPAREN ( invokeExprs )? RPAREN )?
			int alt18=2;
			try { DebugEnterSubRule(18);
			try { DebugEnterDecision(18, false);
			int LA18_0 = input.LA(1);

			if ((LA18_0==DOT))
			{
				alt18 = 1;
			}
			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:86:8: DOT ID LPAREN ( invokeExprs )? RPAREN
				{
				DebugLocation(86, 8);
				DOT51=(CommonToken)Match(input,DOT,Follow._DOT_in_dot472);  
				stream_DOT.Add(DOT51);

				DebugLocation(86, 12);
				ID52=(CommonToken)Match(input,ID,Follow._ID_in_dot474);  
				stream_ID.Add(ID52);

				DebugLocation(86, 15);
				LPAREN53=(CommonToken)Match(input,LPAREN,Follow._LPAREN_in_dot476);  
				stream_LPAREN.Add(LPAREN53);

				DebugLocation(86, 22);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:86:22: ( invokeExprs )?
				int alt17=2;
				try { DebugEnterSubRule(17);
				try { DebugEnterDecision(17, false);
				int LA17_0 = input.LA(1);

				if ((LA17_0==CHAR||(LA17_0>=FALSE && LA17_0<=FLOAT)||(LA17_0>=ID && LA17_0<=ISVOID)||LA17_0==LCURLY||LA17_0==LPAREN||(LA17_0>=NEG && LA17_0<=NOT)||LA17_0==RETURN||LA17_0==STRING||LA17_0==TRUE||(LA17_0>=VAR && LA17_0<=VOID)||LA17_0==WHILE))
				{
					alt17 = 1;
				}
				} finally { DebugExitDecision(17); }
				switch (alt17)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:86:22: invokeExprs
					{
					DebugLocation(86, 22);
					PushFollow(Follow._invokeExprs_in_dot478);
					invokeExprs54=invokeExprs();
					PopFollow();

					stream_invokeExprs.Add(invokeExprs54.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(17); }

				DebugLocation(86, 35);
				RPAREN55=(CommonToken)Match(input,RPAREN,Follow._RPAREN_in_dot481);  
				stream_RPAREN.Add(RPAREN55);


				}
				break;

			}
			} finally { DebugExitSubRule(18); }



			{
			// AST REWRITE
			// elements: ID, term, invokeExprs
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 86:44: -> ^( Term term ( ID )? ( invokeExprs )? )
			{
				DebugLocation(87, 3);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:87:3: ^( Term term ( ID )? ( invokeExprs )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(87, 5);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Term, "Term"), root_1);

				DebugLocation(87, 10);
				adaptor.AddChild(root_1, stream_term.NextTree());
				DebugLocation(87, 15);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:87:15: ( ID )?
				if (stream_ID.HasNext)
				{
					DebugLocation(87, 15);
					adaptor.AddChild(root_1, stream_ID.NextNode());

				}
				stream_ID.Reset();
				DebugLocation(87, 19);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:87:19: ( invokeExprs )?
				if (stream_invokeExprs.HasNext)
				{
					DebugLocation(87, 19);
					adaptor.AddChild(root_1, stream_invokeExprs.NextTree());

				}
				stream_invokeExprs.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("dot", 14);
			LeaveRule("dot", 14);
			LeaveRule_dot();
		}
		DebugLocation(87, 31);
		} finally { DebugExitRule(GrammarFileName, "dot"); }
		return retval;

	}
	// $ANTLR end "dot"

	partial void EnterRule_term();
	partial void LeaveRule_term();

	// $ANTLR start "term"
	// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:89:1: term : ( ID LPAREN ( invokeExprs )? RPAREN -> ^( ImplicitInvoke ID ( invokeExprs )? ) | IF ^ expr THEN ! expr ELSE ! expr ENDIF !| WHILE ^ expr LOOP ! expr ENDLOOP !| LCURLY ( expr SEMI )+ RCURLY -> ^( Exprs ( expr )+ ) | VAR ! varExprs | NEW ^ typeName | RETURN ^ expr | LPAREN expr RPAREN -> ^( Expr expr ) | ID ^| INTEGER ^| FLOAT ^| STRING ^| CHAR ^| TRUE ^| FALSE ^| VOID ^);
	[GrammarRule("term")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> term()
	{
		EnterRule_term();
		EnterRule("term", 15);
		TraceIn("term", 15);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken ID56 = default(CommonToken);
		CommonToken LPAREN57 = default(CommonToken);
		CommonToken RPAREN59 = default(CommonToken);
		CommonToken IF60 = default(CommonToken);
		CommonToken THEN62 = default(CommonToken);
		CommonToken ELSE64 = default(CommonToken);
		CommonToken ENDIF66 = default(CommonToken);
		CommonToken WHILE67 = default(CommonToken);
		CommonToken LOOP69 = default(CommonToken);
		CommonToken ENDLOOP71 = default(CommonToken);
		CommonToken LCURLY72 = default(CommonToken);
		CommonToken SEMI74 = default(CommonToken);
		CommonToken RCURLY75 = default(CommonToken);
		CommonToken VAR76 = default(CommonToken);
		CommonToken NEW78 = default(CommonToken);
		CommonToken RETURN80 = default(CommonToken);
		CommonToken LPAREN82 = default(CommonToken);
		CommonToken RPAREN84 = default(CommonToken);
		CommonToken ID85 = default(CommonToken);
		CommonToken INTEGER86 = default(CommonToken);
		CommonToken FLOAT87 = default(CommonToken);
		CommonToken STRING88 = default(CommonToken);
		CommonToken CHAR89 = default(CommonToken);
		CommonToken TRUE90 = default(CommonToken);
		CommonToken FALSE91 = default(CommonToken);
		CommonToken VOID92 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> invokeExprs58 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr61 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr63 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr65 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr68 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr70 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr73 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> varExprs77 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> typeName79 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr81 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr83 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree ID56_tree = default(CommonTree);
		CommonTree LPAREN57_tree = default(CommonTree);
		CommonTree RPAREN59_tree = default(CommonTree);
		CommonTree IF60_tree = default(CommonTree);
		CommonTree THEN62_tree = default(CommonTree);
		CommonTree ELSE64_tree = default(CommonTree);
		CommonTree ENDIF66_tree = default(CommonTree);
		CommonTree WHILE67_tree = default(CommonTree);
		CommonTree LOOP69_tree = default(CommonTree);
		CommonTree ENDLOOP71_tree = default(CommonTree);
		CommonTree LCURLY72_tree = default(CommonTree);
		CommonTree SEMI74_tree = default(CommonTree);
		CommonTree RCURLY75_tree = default(CommonTree);
		CommonTree VAR76_tree = default(CommonTree);
		CommonTree NEW78_tree = default(CommonTree);
		CommonTree RETURN80_tree = default(CommonTree);
		CommonTree LPAREN82_tree = default(CommonTree);
		CommonTree RPAREN84_tree = default(CommonTree);
		CommonTree ID85_tree = default(CommonTree);
		CommonTree INTEGER86_tree = default(CommonTree);
		CommonTree FLOAT87_tree = default(CommonTree);
		CommonTree STRING88_tree = default(CommonTree);
		CommonTree CHAR89_tree = default(CommonTree);
		CommonTree TRUE90_tree = default(CommonTree);
		CommonTree FALSE91_tree = default(CommonTree);
		CommonTree VOID92_tree = default(CommonTree);
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_LCURLY=new RewriteRuleITokenStream(adaptor,"token LCURLY");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RCURLY=new RewriteRuleITokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_invokeExprs=new RewriteRuleSubtreeStream(adaptor,"rule invokeExprs");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "term");
		DebugLocation(89, 8);
		try
		{
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:89:5: ( ID LPAREN ( invokeExprs )? RPAREN -> ^( ImplicitInvoke ID ( invokeExprs )? ) | IF ^ expr THEN ! expr ELSE ! expr ENDIF !| WHILE ^ expr LOOP ! expr ENDLOOP !| LCURLY ( expr SEMI )+ RCURLY -> ^( Exprs ( expr )+ ) | VAR ! varExprs | NEW ^ typeName | RETURN ^ expr | LPAREN expr RPAREN -> ^( Expr expr ) | ID ^| INTEGER ^| FLOAT ^| STRING ^| CHAR ^| TRUE ^| FALSE ^| VOID ^)
			int alt21=16;
			try { DebugEnterDecision(21, false);
			switch (input.LA(1))
			{
			case ID:
				{
				int LA21_1 = input.LA(2);

				if ((LA21_1==LPAREN))
				{
					alt21 = 1;
				}
				else if ((LA21_1==COMMA||(LA21_1>=DIV && LA21_1<=EQUAL)||(LA21_1>=GE && LA21_1<=ID)||LA21_1==LE||LA21_1==LOOP||LA21_1==LT||(LA21_1>=MINUS && LA21_1<=MULT)||(LA21_1>=PLUS && LA21_1<=RCURLY)||(LA21_1>=RPAREN && LA21_1<=SEMI)||LA21_1==THEN))
				{
					alt21 = 9;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 21, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case IF:
				{
				alt21 = 2;
				}
				break;
			case WHILE:
				{
				alt21 = 3;
				}
				break;
			case LCURLY:
				{
				alt21 = 4;
				}
				break;
			case VAR:
				{
				alt21 = 5;
				}
				break;
			case NEW:
				{
				alt21 = 6;
				}
				break;
			case RETURN:
				{
				alt21 = 7;
				}
				break;
			case LPAREN:
				{
				alt21 = 8;
				}
				break;
			case INTEGER:
				{
				alt21 = 10;
				}
				break;
			case FLOAT:
				{
				alt21 = 11;
				}
				break;
			case STRING:
				{
				alt21 = 12;
				}
				break;
			case CHAR:
				{
				alt21 = 13;
				}
				break;
			case TRUE:
				{
				alt21 = 14;
				}
				break;
			case FALSE:
				{
				alt21 = 15;
				}
				break;
			case VOID:
				{
				alt21 = 16;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 21, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:90:4: ID LPAREN ( invokeExprs )? RPAREN
				{
				DebugLocation(90, 4);
				ID56=(CommonToken)Match(input,ID,Follow._ID_in_term509);  
				stream_ID.Add(ID56);

				DebugLocation(90, 7);
				LPAREN57=(CommonToken)Match(input,LPAREN,Follow._LPAREN_in_term511);  
				stream_LPAREN.Add(LPAREN57);

				DebugLocation(90, 14);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:90:14: ( invokeExprs )?
				int alt19=2;
				try { DebugEnterSubRule(19);
				try { DebugEnterDecision(19, false);
				int LA19_0 = input.LA(1);

				if ((LA19_0==CHAR||(LA19_0>=FALSE && LA19_0<=FLOAT)||(LA19_0>=ID && LA19_0<=ISVOID)||LA19_0==LCURLY||LA19_0==LPAREN||(LA19_0>=NEG && LA19_0<=NOT)||LA19_0==RETURN||LA19_0==STRING||LA19_0==TRUE||(LA19_0>=VAR && LA19_0<=VOID)||LA19_0==WHILE))
				{
					alt19 = 1;
				}
				} finally { DebugExitDecision(19); }
				switch (alt19)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:90:14: invokeExprs
					{
					DebugLocation(90, 14);
					PushFollow(Follow._invokeExprs_in_term513);
					invokeExprs58=invokeExprs();
					PopFollow();

					stream_invokeExprs.Add(invokeExprs58.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(19); }

				DebugLocation(90, 27);
				RPAREN59=(CommonToken)Match(input,RPAREN,Follow._RPAREN_in_term516);  
				stream_RPAREN.Add(RPAREN59);



				{
				// AST REWRITE
				// elements: ID, invokeExprs
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 90:34: -> ^( ImplicitInvoke ID ( invokeExprs )? )
				{
					DebugLocation(90, 37);
					// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:90:37: ^( ImplicitInvoke ID ( invokeExprs )? )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(90, 39);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ImplicitInvoke, "ImplicitInvoke"), root_1);

					DebugLocation(90, 54);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(90, 57);
					// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:90:57: ( invokeExprs )?
					if (stream_invokeExprs.HasNext)
					{
						DebugLocation(90, 57);
						adaptor.AddChild(root_1, stream_invokeExprs.NextTree());

					}
					stream_invokeExprs.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:91:4: IF ^ expr THEN ! expr ELSE ! expr ENDIF !
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(91, 6);
				IF60=(CommonToken)Match(input,IF,Follow._IF_in_term532); 
				IF60_tree = (CommonTree)adaptor.Create(IF60);
				root_0 = (CommonTree)adaptor.BecomeRoot(IF60_tree, root_0);
				DebugLocation(91, 8);
				PushFollow(Follow._expr_in_term535);
				expr61=expr();
				PopFollow();

				adaptor.AddChild(root_0, expr61.Tree);
				DebugLocation(91, 17);
				THEN62=(CommonToken)Match(input,THEN,Follow._THEN_in_term537); 
				DebugLocation(91, 19);
				PushFollow(Follow._expr_in_term540);
				expr63=expr();
				PopFollow();

				adaptor.AddChild(root_0, expr63.Tree);
				DebugLocation(91, 28);
				ELSE64=(CommonToken)Match(input,ELSE,Follow._ELSE_in_term542); 
				DebugLocation(91, 30);
				PushFollow(Follow._expr_in_term545);
				expr65=expr();
				PopFollow();

				adaptor.AddChild(root_0, expr65.Tree);
				DebugLocation(91, 40);
				ENDIF66=(CommonToken)Match(input,ENDIF,Follow._ENDIF_in_term547); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:92:4: WHILE ^ expr LOOP ! expr ENDLOOP !
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(92, 9);
				WHILE67=(CommonToken)Match(input,WHILE,Follow._WHILE_in_term553); 
				WHILE67_tree = (CommonTree)adaptor.Create(WHILE67);
				root_0 = (CommonTree)adaptor.BecomeRoot(WHILE67_tree, root_0);
				DebugLocation(92, 11);
				PushFollow(Follow._expr_in_term556);
				expr68=expr();
				PopFollow();

				adaptor.AddChild(root_0, expr68.Tree);
				DebugLocation(92, 20);
				LOOP69=(CommonToken)Match(input,LOOP,Follow._LOOP_in_term558); 
				DebugLocation(92, 22);
				PushFollow(Follow._expr_in_term561);
				expr70=expr();
				PopFollow();

				adaptor.AddChild(root_0, expr70.Tree);
				DebugLocation(92, 34);
				ENDLOOP71=(CommonToken)Match(input,ENDLOOP,Follow._ENDLOOP_in_term563); 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:93:4: LCURLY ( expr SEMI )+ RCURLY
				{
				DebugLocation(93, 4);
				LCURLY72=(CommonToken)Match(input,LCURLY,Follow._LCURLY_in_term569);  
				stream_LCURLY.Add(LCURLY72);

				DebugLocation(93, 11);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:93:11: ( expr SEMI )+
				int cnt20=0;
				try { DebugEnterSubRule(20);
				while (true)
				{
					int alt20=2;
					try { DebugEnterDecision(20, false);
					int LA20_0 = input.LA(1);

					if ((LA20_0==CHAR||(LA20_0>=FALSE && LA20_0<=FLOAT)||(LA20_0>=ID && LA20_0<=ISVOID)||LA20_0==LCURLY||LA20_0==LPAREN||(LA20_0>=NEG && LA20_0<=NOT)||LA20_0==RETURN||LA20_0==STRING||LA20_0==TRUE||(LA20_0>=VAR && LA20_0<=VOID)||LA20_0==WHILE))
					{
						alt20 = 1;
					}


					} finally { DebugExitDecision(20); }
					switch (alt20)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:93:12: expr SEMI
						{
						DebugLocation(93, 12);
						PushFollow(Follow._expr_in_term572);
						expr73=expr();
						PopFollow();

						stream_expr.Add(expr73.Tree);
						DebugLocation(93, 17);
						SEMI74=(CommonToken)Match(input,SEMI,Follow._SEMI_in_term574);  
						stream_SEMI.Add(SEMI74);


						}
						break;

					default:
						if (cnt20 >= 1)
							goto loop20;

						EarlyExitException eee20 = new EarlyExitException( 20, input );
						DebugRecognitionException(eee20);
						throw eee20;
					}
					cnt20++;
				}
				loop20:
					;

				} finally { DebugExitSubRule(20); }

				DebugLocation(93, 24);
				RCURLY75=(CommonToken)Match(input,RCURLY,Follow._RCURLY_in_term578);  
				stream_RCURLY.Add(RCURLY75);



				{
				// AST REWRITE
				// elements: expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 93:31: -> ^( Exprs ( expr )+ )
				{
					DebugLocation(93, 34);
					// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:93:34: ^( Exprs ( expr )+ )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(93, 36);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Exprs, "Exprs"), root_1);

					DebugLocation(93, 42);
					if (!(stream_expr.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_expr.HasNext )
					{
						DebugLocation(93, 42);
						adaptor.AddChild(root_1, stream_expr.NextTree());

					}
					stream_expr.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:94:4: VAR ! varExprs
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(94, 7);
				VAR76=(CommonToken)Match(input,VAR,Follow._VAR_in_term592); 
				DebugLocation(94, 9);
				PushFollow(Follow._varExprs_in_term595);
				varExprs77=varExprs();
				PopFollow();

				adaptor.AddChild(root_0, varExprs77.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:95:4: NEW ^ typeName
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(95, 7);
				NEW78=(CommonToken)Match(input,NEW,Follow._NEW_in_term600); 
				NEW78_tree = (CommonTree)adaptor.Create(NEW78);
				root_0 = (CommonTree)adaptor.BecomeRoot(NEW78_tree, root_0);
				DebugLocation(95, 9);
				PushFollow(Follow._typeName_in_term603);
				typeName79=typeName();
				PopFollow();

				adaptor.AddChild(root_0, typeName79.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:96:4: RETURN ^ expr
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(96, 10);
				RETURN80=(CommonToken)Match(input,RETURN,Follow._RETURN_in_term608); 
				RETURN80_tree = (CommonTree)adaptor.Create(RETURN80);
				root_0 = (CommonTree)adaptor.BecomeRoot(RETURN80_tree, root_0);
				DebugLocation(96, 12);
				PushFollow(Follow._expr_in_term611);
				expr81=expr();
				PopFollow();

				adaptor.AddChild(root_0, expr81.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:97:4: LPAREN expr RPAREN
				{
				DebugLocation(97, 4);
				LPAREN82=(CommonToken)Match(input,LPAREN,Follow._LPAREN_in_term616);  
				stream_LPAREN.Add(LPAREN82);

				DebugLocation(97, 11);
				PushFollow(Follow._expr_in_term618);
				expr83=expr();
				PopFollow();

				stream_expr.Add(expr83.Tree);
				DebugLocation(97, 16);
				RPAREN84=(CommonToken)Match(input,RPAREN,Follow._RPAREN_in_term620);  
				stream_RPAREN.Add(RPAREN84);



				{
				// AST REWRITE
				// elements: expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 97:23: -> ^( Expr expr )
				{
					DebugLocation(97, 26);
					// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:97:26: ^( Expr expr )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(97, 28);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Expr, "Expr"), root_1);

					DebugLocation(97, 33);
					adaptor.AddChild(root_1, stream_expr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:98:4: ID ^
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(98, 6);
				ID85=(CommonToken)Match(input,ID,Follow._ID_in_term633); 
				ID85_tree = (CommonTree)adaptor.Create(ID85);
				root_0 = (CommonTree)adaptor.BecomeRoot(ID85_tree, root_0);

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:99:4: INTEGER ^
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(99, 11);
				INTEGER86=(CommonToken)Match(input,INTEGER,Follow._INTEGER_in_term639); 
				INTEGER86_tree = (CommonTree)adaptor.Create(INTEGER86);
				root_0 = (CommonTree)adaptor.BecomeRoot(INTEGER86_tree, root_0);

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:100:4: FLOAT ^
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(100, 9);
				FLOAT87=(CommonToken)Match(input,FLOAT,Follow._FLOAT_in_term645); 
				FLOAT87_tree = (CommonTree)adaptor.Create(FLOAT87);
				root_0 = (CommonTree)adaptor.BecomeRoot(FLOAT87_tree, root_0);

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:101:4: STRING ^
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(101, 10);
				STRING88=(CommonToken)Match(input,STRING,Follow._STRING_in_term651); 
				STRING88_tree = (CommonTree)adaptor.Create(STRING88);
				root_0 = (CommonTree)adaptor.BecomeRoot(STRING88_tree, root_0);

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:102:4: CHAR ^
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(102, 8);
				CHAR89=(CommonToken)Match(input,CHAR,Follow._CHAR_in_term657); 
				CHAR89_tree = (CommonTree)adaptor.Create(CHAR89);
				root_0 = (CommonTree)adaptor.BecomeRoot(CHAR89_tree, root_0);

				}
				break;
			case 14:
				DebugEnterAlt(14);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:103:4: TRUE ^
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(103, 8);
				TRUE90=(CommonToken)Match(input,TRUE,Follow._TRUE_in_term663); 
				TRUE90_tree = (CommonTree)adaptor.Create(TRUE90);
				root_0 = (CommonTree)adaptor.BecomeRoot(TRUE90_tree, root_0);

				}
				break;
			case 15:
				DebugEnterAlt(15);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:104:4: FALSE ^
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(104, 9);
				FALSE91=(CommonToken)Match(input,FALSE,Follow._FALSE_in_term669); 
				FALSE91_tree = (CommonTree)adaptor.Create(FALSE91);
				root_0 = (CommonTree)adaptor.BecomeRoot(FALSE91_tree, root_0);

				}
				break;
			case 16:
				DebugEnterAlt(16);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:105:4: VOID ^
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(105, 8);
				VOID92=(CommonToken)Match(input,VOID,Follow._VOID_in_term675); 
				VOID92_tree = (CommonTree)adaptor.Create(VOID92);
				root_0 = (CommonTree)adaptor.BecomeRoot(VOID92_tree, root_0);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("term", 15);
			LeaveRule("term", 15);
			LeaveRule_term();
		}
		DebugLocation(105, 8);
		} finally { DebugExitRule(GrammarFileName, "term"); }
		return retval;

	}
	// $ANTLR end "term"

	partial void EnterRule_invokeExprs();
	partial void LeaveRule_invokeExprs();

	// $ANTLR start "invokeExprs"
	// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:107:1: invokeExprs : expr ( COMMA expr )* -> ^( InvokeExprs ( expr )+ ) ;
	[GrammarRule("invokeExprs")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> invokeExprs()
	{
		EnterRule_invokeExprs();
		EnterRule("invokeExprs", 16);
		TraceIn("invokeExprs", 16);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken COMMA94 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr93 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr95 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree COMMA94_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "invokeExprs");
		DebugLocation(107, 43);
		try
		{
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:107:12: ( expr ( COMMA expr )* -> ^( InvokeExprs ( expr )+ ) )
			DebugEnterAlt(1);
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:108:2: expr ( COMMA expr )*
			{
			DebugLocation(108, 2);
			PushFollow(Follow._expr_in_invokeExprs684);
			expr93=expr();
			PopFollow();

			stream_expr.Add(expr93.Tree);
			DebugLocation(108, 7);
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:108:7: ( COMMA expr )*
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=2;
				try { DebugEnterDecision(22, false);
				int LA22_0 = input.LA(1);

				if ((LA22_0==COMMA))
				{
					alt22 = 1;
				}


				} finally { DebugExitDecision(22); }
				switch ( alt22 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:108:8: COMMA expr
					{
					DebugLocation(108, 8);
					COMMA94=(CommonToken)Match(input,COMMA,Follow._COMMA_in_invokeExprs687);  
					stream_COMMA.Add(COMMA94);

					DebugLocation(108, 14);
					PushFollow(Follow._expr_in_invokeExprs689);
					expr95=expr();
					PopFollow();

					stream_expr.Add(expr95.Tree);

					}
					break;

				default:
					goto loop22;
				}
			}

			loop22:
				;

			} finally { DebugExitSubRule(22); }



			{
			// AST REWRITE
			// elements: expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 108:21: -> ^( InvokeExprs ( expr )+ )
			{
				DebugLocation(108, 24);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:108:24: ^( InvokeExprs ( expr )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(108, 26);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(InvokeExprs, "InvokeExprs"), root_1);

				DebugLocation(108, 38);
				if (!(stream_expr.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_expr.HasNext )
				{
					DebugLocation(108, 38);
					adaptor.AddChild(root_1, stream_expr.NextTree());

				}
				stream_expr.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("invokeExprs", 16);
			LeaveRule("invokeExprs", 16);
			LeaveRule_invokeExprs();
		}
		DebugLocation(108, 43);
		} finally { DebugExitRule(GrammarFileName, "invokeExprs"); }
		return retval;

	}
	// $ANTLR end "invokeExprs"

	partial void EnterRule_varExprs();
	partial void LeaveRule_varExprs();

	// $ANTLR start "varExprs"
	// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:110:1: varExprs : localOrFieldInit ( COMMA localOrFieldInit )* -> ^( VarExprs ( localOrFieldInit )+ ) ;
	[GrammarRule("varExprs")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> varExprs()
	{
		EnterRule_varExprs();
		EnterRule("varExprs", 17);
		TraceIn("varExprs", 17);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken COMMA97 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> localOrFieldInit96 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> localOrFieldInit98 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree COMMA97_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_localOrFieldInit=new RewriteRuleSubtreeStream(adaptor,"rule localOrFieldInit");
		try { DebugEnterRule(GrammarFileName, "varExprs");
		DebugLocation(110, 76);
		try
		{
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:110:9: ( localOrFieldInit ( COMMA localOrFieldInit )* -> ^( VarExprs ( localOrFieldInit )+ ) )
			DebugEnterAlt(1);
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:111:2: localOrFieldInit ( COMMA localOrFieldInit )*
			{
			DebugLocation(111, 2);
			PushFollow(Follow._localOrFieldInit_in_varExprs710);
			localOrFieldInit96=localOrFieldInit();
			PopFollow();

			stream_localOrFieldInit.Add(localOrFieldInit96.Tree);
			DebugLocation(111, 19);
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:111:19: ( COMMA localOrFieldInit )*
			try { DebugEnterSubRule(23);
			while (true)
			{
				int alt23=2;
				try { DebugEnterDecision(23, false);
				int LA23_0 = input.LA(1);

				if ((LA23_0==COMMA))
				{
					alt23 = 1;
				}


				} finally { DebugExitDecision(23); }
				switch ( alt23 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:111:20: COMMA localOrFieldInit
					{
					DebugLocation(111, 20);
					COMMA97=(CommonToken)Match(input,COMMA,Follow._COMMA_in_varExprs713);  
					stream_COMMA.Add(COMMA97);

					DebugLocation(111, 26);
					PushFollow(Follow._localOrFieldInit_in_varExprs715);
					localOrFieldInit98=localOrFieldInit();
					PopFollow();

					stream_localOrFieldInit.Add(localOrFieldInit98.Tree);

					}
					break;

				default:
					goto loop23;
				}
			}

			loop23:
				;

			} finally { DebugExitSubRule(23); }



			{
			// AST REWRITE
			// elements: localOrFieldInit
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 111:45: -> ^( VarExprs ( localOrFieldInit )+ )
			{
				DebugLocation(111, 48);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:111:48: ^( VarExprs ( localOrFieldInit )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(111, 50);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(VarExprs, "VarExprs"), root_1);

				DebugLocation(111, 59);
				if (!(stream_localOrFieldInit.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_localOrFieldInit.HasNext )
				{
					DebugLocation(111, 59);
					adaptor.AddChild(root_1, stream_localOrFieldInit.NextTree());

				}
				stream_localOrFieldInit.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("varExprs", 17);
			LeaveRule("varExprs", 17);
			LeaveRule_varExprs();
		}
		DebugLocation(111, 76);
		} finally { DebugExitRule(GrammarFileName, "varExprs"); }
		return retval;

	}
	// $ANTLR end "varExprs"

	partial void EnterRule_localOrFieldInit();
	partial void LeaveRule_localOrFieldInit();

	// $ANTLR start "localOrFieldInit"
	// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:113:1: localOrFieldInit : ID COLON typeName ( ASSIGN expr )? -> ^( LocalOrFieldInit ID typeName ( expr )? ) ;
	[GrammarRule("localOrFieldInit")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> localOrFieldInit()
	{
		EnterRule_localOrFieldInit();
		EnterRule("localOrFieldInit", 18);
		TraceIn("localOrFieldInit", 18);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken ID99 = default(CommonToken);
		CommonToken COLON100 = default(CommonToken);
		CommonToken ASSIGN102 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> typeName101 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr103 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree ID99_tree = default(CommonTree);
		CommonTree COLON100_tree = default(CommonTree);
		CommonTree ASSIGN102_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_typeName=new RewriteRuleSubtreeStream(adaptor,"rule typeName");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "localOrFieldInit");
		DebugLocation(113, 74);
		try
		{
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:113:17: ( ID COLON typeName ( ASSIGN expr )? -> ^( LocalOrFieldInit ID typeName ( expr )? ) )
			DebugEnterAlt(1);
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:114:2: ID COLON typeName ( ASSIGN expr )?
			{
			DebugLocation(114, 2);
			ID99=(CommonToken)Match(input,ID,Follow._ID_in_localOrFieldInit735);  
			stream_ID.Add(ID99);

			DebugLocation(114, 5);
			COLON100=(CommonToken)Match(input,COLON,Follow._COLON_in_localOrFieldInit737);  
			stream_COLON.Add(COLON100);

			DebugLocation(114, 11);
			PushFollow(Follow._typeName_in_localOrFieldInit739);
			typeName101=typeName();
			PopFollow();

			stream_typeName.Add(typeName101.Tree);
			DebugLocation(114, 20);
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:114:20: ( ASSIGN expr )?
			int alt24=2;
			try { DebugEnterSubRule(24);
			try { DebugEnterDecision(24, false);
			int LA24_0 = input.LA(1);

			if ((LA24_0==ASSIGN))
			{
				alt24 = 1;
			}
			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:114:21: ASSIGN expr
				{
				DebugLocation(114, 21);
				ASSIGN102=(CommonToken)Match(input,ASSIGN,Follow._ASSIGN_in_localOrFieldInit742);  
				stream_ASSIGN.Add(ASSIGN102);

				DebugLocation(114, 28);
				PushFollow(Follow._expr_in_localOrFieldInit744);
				expr103=expr();
				PopFollow();

				stream_expr.Add(expr103.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(24); }



			{
			// AST REWRITE
			// elements: expr, ID, typeName
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 114:35: -> ^( LocalOrFieldInit ID typeName ( expr )? )
			{
				DebugLocation(114, 38);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:114:38: ^( LocalOrFieldInit ID typeName ( expr )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(114, 40);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(LocalOrFieldInit, "LocalOrFieldInit"), root_1);

				DebugLocation(114, 57);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(114, 60);
				adaptor.AddChild(root_1, stream_typeName.NextTree());
				DebugLocation(114, 69);
				// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:114:69: ( expr )?
				if (stream_expr.HasNext)
				{
					DebugLocation(114, 69);
					adaptor.AddChild(root_1, stream_expr.NextTree());

				}
				stream_expr.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("localOrFieldInit", 18);
			LeaveRule("localOrFieldInit", 18);
			LeaveRule_localOrFieldInit();
		}
		DebugLocation(114, 74);
		} finally { DebugExitRule(GrammarFileName, "localOrFieldInit"); }
		return retval;

	}
	// $ANTLR end "localOrFieldInit"

	partial void EnterRule_typeName();
	partial void LeaveRule_typeName();

	// $ANTLR start "typeName"
	// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:116:1: typeName : ( IntTypeName | FloatTypeName | BoolTypeName | StringTypeName | CharTypeName | ObjectTypeName | ID );
	[GrammarRule("typeName")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> typeName()
	{
		EnterRule_typeName();
		EnterRule("typeName", 19);
		TraceIn("typeName", 19);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken set104 = default(CommonToken);

		CommonTree set104_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "typeName");
		DebugLocation(116, 5);
		try
		{
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:117:2: ( IntTypeName | FloatTypeName | BoolTypeName | StringTypeName | CharTypeName | ObjectTypeName | ID )
			DebugEnterAlt(1);
			// C:\\Users\\F1nZeR\\Desktop\\OVSYANNIKOV\\CK.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(117, 2);

			set104=(CommonToken)input.LT(1);
			if (input.LA(1)==BoolTypeName||input.LA(1)==CharTypeName||input.LA(1)==FloatTypeName||input.LA(1)==ID||input.LA(1)==IntTypeName||input.LA(1)==ObjectTypeName||input.LA(1)==StringTypeName)
			{
				input.Consume();
				adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set104));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("typeName", 19);
			LeaveRule("typeName", 19);
			LeaveRule_typeName();
		}
		DebugLocation(123, 5);
		} finally { DebugExitRule(GrammarFileName, "typeName"); }
		return retval;

	}
	// $ANTLR end "typeName"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _classDef_in_program146 = new BitSet(new ulong[]{0x82UL});
		public static readonly BitSet _CLASS_in_classDef167 = new BitSet(new ulong[]{0x810002108000820UL});
		public static readonly BitSet _typeName_in_classDef169 = new BitSet(new ulong[]{0x8000000100UL});
		public static readonly BitSet _COLON_in_classDef172 = new BitSet(new ulong[]{0x810002108000820UL});
		public static readonly BitSet _typeName_in_classDef174 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _LCURLY_in_classDef178 = new BitSet(new ulong[]{0x40000100000000UL});
		public static readonly BitSet _featureList_in_classDef180 = new BitSet(new ulong[]{0x40000000000000UL});
		public static readonly BitSet _RCURLY_in_classDef182 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _feature_in_featureList208 = new BitSet(new ulong[]{0x100000002UL});
		public static readonly BitSet _ID_in_feature231 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _LPAREN_in_feature233 = new BitSet(new ulong[]{0x100000100000000UL});
		public static readonly BitSet _formalList_in_feature236 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _RPAREN_in_feature240 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _COLON_in_feature242 = new BitSet(new ulong[]{0x810002108000820UL});
		public static readonly BitSet _typeName_in_feature244 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _LCURLY_in_feature246 = new BitSet(new ulong[]{0xA48E088F03000040UL,0x5UL});
		public static readonly BitSet _expr_in_feature248 = new BitSet(new ulong[]{0x40000000000000UL});
		public static readonly BitSet _RCURLY_in_feature250 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _localOrFieldInit_in_feature277 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _formal_in_formalList286 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _COMMA_in_formalList289 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _formal_in_formalList291 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _ID_in_formal309 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _COLON_in_formal311 = new BitSet(new ulong[]{0x810002108000820UL});
		public static readonly BitSet _typeName_in_formal314 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_expr323 = new BitSet(new ulong[]{0x10UL});
		public static readonly BitSet _ASSIGN_in_expr325 = new BitSet(new ulong[]{0xA48E088F03000040UL,0x5UL});
		public static readonly BitSet _not_in_expr330 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_in_not341 = new BitSet(new ulong[]{0xA48E088F03000040UL,0x5UL});
		public static readonly BitSet _relation_in_not346 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _addition_in_relation355 = new BitSet(new ulong[]{0x1100C0100002UL});
		public static readonly BitSet _LE_in_relation359 = new BitSet(new ulong[]{0xA486088F03000040UL,0x5UL});
		public static readonly BitSet _LT_in_relation364 = new BitSet(new ulong[]{0xA486088F03000040UL,0x5UL});
		public static readonly BitSet _GE_in_relation369 = new BitSet(new ulong[]{0xA486088F03000040UL,0x5UL});
		public static readonly BitSet _GT_in_relation374 = new BitSet(new ulong[]{0xA486088F03000040UL,0x5UL});
		public static readonly BitSet _EQUAL_in_relation379 = new BitSet(new ulong[]{0xA486088F03000040UL,0x5UL});
		public static readonly BitSet _addition_in_relation383 = new BitSet(new ulong[]{0x1100C0100002UL});
		public static readonly BitSet _multiplication_in_addition394 = new BitSet(new ulong[]{0x20400000000002UL});
		public static readonly BitSet _PLUS_in_addition398 = new BitSet(new ulong[]{0xA486088F03000040UL,0x5UL});
		public static readonly BitSet _MINUS_in_addition403 = new BitSet(new ulong[]{0xA486088F03000040UL,0x5UL});
		public static readonly BitSet _multiplication_in_addition407 = new BitSet(new ulong[]{0x20400000000002UL});
		public static readonly BitSet _isvoid_in_multiplication417 = new BitSet(new ulong[]{0x800000008002UL});
		public static readonly BitSet _MULT_in_multiplication421 = new BitSet(new ulong[]{0xA486088F03000040UL,0x5UL});
		public static readonly BitSet _DIV_in_multiplication426 = new BitSet(new ulong[]{0xA486088F03000040UL,0x5UL});
		public static readonly BitSet _isvoid_in_multiplication430 = new BitSet(new ulong[]{0x800000008002UL});
		public static readonly BitSet _ISVOID_in_isvoid441 = new BitSet(new ulong[]{0xA486088F03000040UL,0x5UL});
		public static readonly BitSet _neg_in_isvoid446 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEG_in_neg455 = new BitSet(new ulong[]{0xA486088703000040UL,0x5UL});
		public static readonly BitSet _dot_in_neg460 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _term_in_dot469 = new BitSet(new ulong[]{0x10002UL});
		public static readonly BitSet _DOT_in_dot472 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _ID_in_dot474 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _LPAREN_in_dot476 = new BitSet(new ulong[]{0xA58E088F03000040UL,0x5UL});
		public static readonly BitSet _invokeExprs_in_dot478 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _RPAREN_in_dot481 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_term509 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _LPAREN_in_term511 = new BitSet(new ulong[]{0xA58E088F03000040UL,0x5UL});
		public static readonly BitSet _invokeExprs_in_term513 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _RPAREN_in_term516 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IF_in_term532 = new BitSet(new ulong[]{0xA48E088F03000040UL,0x5UL});
		public static readonly BitSet _expr_in_term535 = new BitSet(new ulong[]{0x1000000000000000UL});
		public static readonly BitSet _THEN_in_term537 = new BitSet(new ulong[]{0xA48E088F03000040UL,0x5UL});
		public static readonly BitSet _expr_in_term540 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _ELSE_in_term542 = new BitSet(new ulong[]{0xA48E088F03000040UL,0x5UL});
		public static readonly BitSet _expr_in_term545 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _ENDIF_in_term547 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILE_in_term553 = new BitSet(new ulong[]{0xA48E088F03000040UL,0x5UL});
		public static readonly BitSet _expr_in_term556 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _LOOP_in_term558 = new BitSet(new ulong[]{0xA48E088F03000040UL,0x5UL});
		public static readonly BitSet _expr_in_term561 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ENDLOOP_in_term563 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LCURLY_in_term569 = new BitSet(new ulong[]{0xA48E088F03000040UL,0x5UL});
		public static readonly BitSet _expr_in_term572 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _SEMI_in_term574 = new BitSet(new ulong[]{0xA4CE088F03000040UL,0x5UL});
		public static readonly BitSet _RCURLY_in_term578 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VAR_in_term592 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _varExprs_in_term595 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEW_in_term600 = new BitSet(new ulong[]{0x810002108000820UL});
		public static readonly BitSet _typeName_in_term603 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RETURN_in_term608 = new BitSet(new ulong[]{0xA48E088F03000040UL,0x5UL});
		public static readonly BitSet _expr_in_term611 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_term616 = new BitSet(new ulong[]{0xA48E088F03000040UL,0x5UL});
		public static readonly BitSet _expr_in_term618 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _RPAREN_in_term620 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_term633 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INTEGER_in_term639 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FLOAT_in_term645 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_in_term651 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CHAR_in_term657 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TRUE_in_term663 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FALSE_in_term669 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VOID_in_term675 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expr_in_invokeExprs684 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _COMMA_in_invokeExprs687 = new BitSet(new ulong[]{0xA48E088F03000040UL,0x5UL});
		public static readonly BitSet _expr_in_invokeExprs689 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _localOrFieldInit_in_varExprs710 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _COMMA_in_varExprs713 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _localOrFieldInit_in_varExprs715 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _ID_in_localOrFieldInit735 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _COLON_in_localOrFieldInit737 = new BitSet(new ulong[]{0x810002108000820UL});
		public static readonly BitSet _typeName_in_localOrFieldInit739 = new BitSet(new ulong[]{0x12UL});
		public static readonly BitSet _ASSIGN_in_localOrFieldInit742 = new BitSet(new ulong[]{0xA48E088F03000040UL,0x5UL});
		public static readonly BitSet _expr_in_localOrFieldInit744 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace CKCompiler.Analyzers
