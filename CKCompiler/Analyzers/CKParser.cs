//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.2 CK.g 2013-09-23 21:20:50

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019

#pragma warning disable 3021

using System.Text;

using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace CKCompiler.Analyzers
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.2")]
[System.CLSCompliant(false)]
public partial class CKParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ASSIGN", "BoolTypeName", "CHAR", "CLASS", "COLON", "COMMA", "COMMENT", "CharTypeName", "Class", "ClassesList", "DIGIT", "DIV", "DOT", "ELSE", "ENDIF", "ENDLOOP", "EQUAL", "Expr", "Exprs", "FALL_THROUGH", "FALSE", "FLOAT", "FeatureList", "FloatTypeName", "FuncDef", "FunctionArgsList", "GE", "GT", "ID", "IF", "INTEGER", "ISVOID", "ImplicitInvoke", "IntTypeName", "InvokeExprs", "LCURLY", "LE", "LETTER", "LOOP", "LPAREN", "LT", "LocalOrFieldInit", "MINUS", "MULT", "MULTILINE_COMMENT", "NEG", "NEW", "NOT", "ObjectTypeName", "PLUS", "RCURLY", "RETURN", "RPAREN", "SEMI", "STRING", "StringTypeName", "THEN", "TRUE", "Term", "VAR", "VOID", "VarExprs", "WHILE", "WS"
	};
	public const int EOF=-1;
	public const int ASSIGN=4;
	public const int BoolTypeName=5;
	public const int CHAR=6;
	public const int CLASS=7;
	public const int COLON=8;
	public const int COMMA=9;
	public const int COMMENT=10;
	public const int CharTypeName=11;
	public const int Class=12;
	public const int ClassesList=13;
	public const int DIGIT=14;
	public const int DIV=15;
	public const int DOT=16;
	public const int ELSE=17;
	public const int ENDIF=18;
	public const int ENDLOOP=19;
	public const int EQUAL=20;
	public const int Expr=21;
	public const int Exprs=22;
	public const int FALL_THROUGH=23;
	public const int FALSE=24;
	public const int FLOAT=25;
	public const int FeatureList=26;
	public const int FloatTypeName=27;
	public const int FuncDef=28;
	public const int FunctionArgsList=29;
	public const int GE=30;
	public const int GT=31;
	public const int ID=32;
	public const int IF=33;
	public const int INTEGER=34;
	public const int ISVOID=35;
	public const int ImplicitInvoke=36;
	public const int IntTypeName=37;
	public const int InvokeExprs=38;
	public const int LCURLY=39;
	public const int LE=40;
	public const int LETTER=41;
	public const int LOOP=42;
	public const int LPAREN=43;
	public const int LT=44;
	public const int LocalOrFieldInit=45;
	public const int MINUS=46;
	public const int MULT=47;
	public const int MULTILINE_COMMENT=48;
	public const int NEG=49;
	public const int NEW=50;
	public const int NOT=51;
	public const int ObjectTypeName=52;
	public const int PLUS=53;
	public const int RCURLY=54;
	public const int RETURN=55;
	public const int RPAREN=56;
	public const int SEMI=57;
	public const int STRING=58;
	public const int StringTypeName=59;
	public const int THEN=60;
	public const int TRUE=61;
	public const int Term=62;
	public const int VAR=63;
	public const int VOID=64;
	public const int VarExprs=65;
	public const int WHILE=66;
	public const int WS=67;

	public CKParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public CKParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return CKParser.tokenNames; } }
	public override string GrammarFileName { get { return "CK.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();
	// $ANTLR start "program"
	// CK.g:44:8: public program : ( classDef SEMI )+ -> ^( ClassesList ( classDef )+ ) ;
	[GrammarRule("program")]
	public AstParserRuleReturnScope<CommonTree, CommonToken> program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken SEMI2 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> classDef1 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree SEMI2_tree = default(CommonTree);
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_classDef=new RewriteRuleSubtreeStream(adaptor,"rule classDef");
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(44, 45);
		try
		{
			// CK.g:44:15: ( ( classDef SEMI )+ -> ^( ClassesList ( classDef )+ ) )
			DebugEnterAlt(1);
			// CK.g:45:2: ( classDef SEMI )+
			{
			DebugLocation(45, 2);
			// CK.g:45:2: ( classDef SEMI )+
			int cnt1=0;
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if ((LA1_1==CLASS))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// CK.g:45:3: classDef SEMI
					{
					DebugLocation(45, 3);
					PushFollow(Follow._classDef_in_program146);
					classDef1=classDef();
					PopFollow();

					stream_classDef.Add(classDef1.Tree);
					DebugLocation(45, 12);
					SEMI2=(CommonToken)Match(input,SEMI,Follow._SEMI_in_program148);  
					stream_SEMI.Add(SEMI2);


					}
					break;

				default:
					if (cnt1 >= 1)
						goto loop1;

					EarlyExitException eee1 = new EarlyExitException( 1, input );
					DebugRecognitionException(eee1);
                        break;
					//throw eee1;
				}
				cnt1++;
			}
			loop1:
				;

			} finally { DebugExitSubRule(1); }



			{
			// AST REWRITE
			// elements: classDef
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 45:19: -> ^( ClassesList ( classDef )+ )
			{
				DebugLocation(45, 22);
				// CK.g:45:22: ^( ClassesList ( classDef )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(45, 24);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ClassesList, "ClassesList"), root_1);

				DebugLocation(45, 36);
				if (!(stream_classDef.HasNext))
				{
				    DebugRecognitionException(new RewriteEarlyExitException());
					//throw new RewriteEarlyExitException();
				}
				while ( stream_classDef.HasNext )
				{
					DebugLocation(45, 36);
					adaptor.AddChild(root_1, stream_classDef.NextTree());

				}
				stream_classDef.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(45, 45);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_classDef();
	partial void LeaveRule_classDef();
	// $ANTLR start "classDef"
	// CK.g:47:1: classDef : CLASS typeName ( COLON typeName )? LCURLY featureList RCURLY -> ^( Class typeName featureList ( typeName )? ) ;
	[GrammarRule("classDef")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> classDef()
	{
		EnterRule_classDef();
		EnterRule("classDef", 2);
		TraceIn("classDef", 2);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken CLASS3 = default(CommonToken);
		CommonToken COLON5 = default(CommonToken);
		CommonToken LCURLY7 = default(CommonToken);
		CommonToken RCURLY9 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> typeName4 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> typeName6 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> featureList8 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree CLASS3_tree = default(CommonTree);
		CommonTree COLON5_tree = default(CommonTree);
		CommonTree LCURLY7_tree = default(CommonTree);
		CommonTree RCURLY9_tree = default(CommonTree);
		RewriteRuleITokenStream stream_CLASS=new RewriteRuleITokenStream(adaptor,"token CLASS");
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_LCURLY=new RewriteRuleITokenStream(adaptor,"token LCURLY");
		RewriteRuleITokenStream stream_RCURLY=new RewriteRuleITokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_typeName=new RewriteRuleSubtreeStream(adaptor,"rule typeName");
		RewriteRuleSubtreeStream stream_featureList=new RewriteRuleSubtreeStream(adaptor,"rule featureList");
		try { DebugEnterRule(GrammarFileName, "classDef");
		DebugLocation(47, 41);
		try
		{
			// CK.g:47:9: ( CLASS typeName ( COLON typeName )? LCURLY featureList RCURLY -> ^( Class typeName featureList ( typeName )? ) )
			DebugEnterAlt(1);
			// CK.g:48:2: CLASS typeName ( COLON typeName )? LCURLY featureList RCURLY
			{
			DebugLocation(48, 2);
			CLASS3=(CommonToken)Match(input,CLASS,Follow._CLASS_in_classDef169);  
			stream_CLASS.Add(CLASS3);

			DebugLocation(48, 8);
			PushFollow(Follow._typeName_in_classDef171);
			typeName4=typeName();
			PopFollow();

			stream_typeName.Add(typeName4.Tree);
			DebugLocation(48, 17);
			// CK.g:48:17: ( COLON typeName )?
			int alt2=2;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, false);
			int LA2_1 = input.LA(1);

			if ((LA2_1==COLON))
			{
				alt2 = 1;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// CK.g:48:18: COLON typeName
				{
				DebugLocation(48, 18);
				COLON5=(CommonToken)Match(input,COLON,Follow._COLON_in_classDef174);  
				stream_COLON.Add(COLON5);

				DebugLocation(48, 24);
				PushFollow(Follow._typeName_in_classDef176);
				typeName6=typeName();
				PopFollow();

				stream_typeName.Add(typeName6.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(2); }

			DebugLocation(48, 35);
			LCURLY7=(CommonToken)Match(input,LCURLY,Follow._LCURLY_in_classDef180);  
			stream_LCURLY.Add(LCURLY7);

			DebugLocation(48, 42);
			PushFollow(Follow._featureList_in_classDef182);
			featureList8=featureList();
			PopFollow();

			stream_featureList.Add(featureList8.Tree);
			DebugLocation(48, 54);
			RCURLY9=(CommonToken)Match(input,RCURLY,Follow._RCURLY_in_classDef184);  
			stream_RCURLY.Add(RCURLY9);



			{
			// AST REWRITE
			// elements: typeName, featureList, typeName
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 48:61: -> ^( Class typeName featureList ( typeName )? )
			{
				DebugLocation(49, 3);
				// CK.g:49:3: ^( Class typeName featureList ( typeName )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(49, 5);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Class, "Class"), root_1);

				DebugLocation(49, 11);
				adaptor.AddChild(root_1, stream_typeName.NextTree());
				DebugLocation(49, 20);
				adaptor.AddChild(root_1, stream_featureList.NextTree());
				DebugLocation(49, 32);
				// CK.g:49:32: ( typeName )?
				if (stream_typeName.HasNext)
				{
					DebugLocation(49, 32);
					adaptor.AddChild(root_1, stream_typeName.NextTree());

				}
				stream_typeName.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("classDef", 2);
			LeaveRule("classDef", 2);
			LeaveRule_classDef();
		}
		DebugLocation(49, 41);
		} finally { DebugExitRule(GrammarFileName, "classDef"); }
		return retval;

	}
	// $ANTLR end "classDef"

	partial void EnterRule_featureList();
	partial void LeaveRule_featureList();
	// $ANTLR start "featureList"
	// CK.g:51:1: featureList : ( feature SEMI )* -> ^( FeatureList ( feature )* ) ;
	[GrammarRule("featureList")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> featureList()
	{
		EnterRule_featureList();
		EnterRule("featureList", 3);
		TraceIn("featureList", 3);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken SEMI11 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> feature10 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree SEMI11_tree = default(CommonTree);
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_feature=new RewriteRuleSubtreeStream(adaptor,"rule feature");
		try { DebugEnterRule(GrammarFileName, "featureList");
		DebugLocation(51, 43);
		try
		{
			// CK.g:51:12: ( ( feature SEMI )* -> ^( FeatureList ( feature )* ) )
			DebugEnterAlt(1);
			// CK.g:52:2: ( feature SEMI )*
			{
			DebugLocation(52, 2);
			// CK.g:52:2: ( feature SEMI )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_1 = input.LA(1);

				if ((LA3_1==ID))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// CK.g:52:3: feature SEMI
					{
					DebugLocation(52, 3);
					PushFollow(Follow._feature_in_featureList210);
					feature10=feature();
					PopFollow();

					stream_feature.Add(feature10.Tree);
					DebugLocation(52, 11);
					SEMI11=(CommonToken)Match(input,SEMI,Follow._SEMI_in_featureList212);  
					stream_SEMI.Add(SEMI11);


					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }



			{
			// AST REWRITE
			// elements: feature
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 52:18: -> ^( FeatureList ( feature )* )
			{
				DebugLocation(52, 21);
				// CK.g:52:21: ^( FeatureList ( feature )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(52, 23);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FeatureList, "FeatureList"), root_1);

				DebugLocation(52, 35);
				// CK.g:52:35: ( feature )*
				while ( stream_feature.HasNext )
				{
					DebugLocation(52, 35);
					adaptor.AddChild(root_1, stream_feature.NextTree());

				}
				stream_feature.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("featureList", 3);
			LeaveRule("featureList", 3);
			LeaveRule_featureList();
		}
		DebugLocation(52, 43);
		} finally { DebugExitRule(GrammarFileName, "featureList"); }
		return retval;

	}
	// $ANTLR end "featureList"

	partial void EnterRule_feature();
	partial void LeaveRule_feature();
	// $ANTLR start "feature"
	// CK.g:54:1: feature : ( ( ID LPAREN ( formalList )? RPAREN COLON typeName LCURLY expr RCURLY ) -> ^( FuncDef ID typeName expr ( formalList )? ) | localOrFieldInit );
	[GrammarRule("feature")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> feature()
	{
		EnterRule_feature();
		EnterRule("feature", 4);
		TraceIn("feature", 4);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken ID12 = default(CommonToken);
		CommonToken LPAREN13 = default(CommonToken);
		CommonToken RPAREN15 = default(CommonToken);
		CommonToken COLON16 = default(CommonToken);
		CommonToken LCURLY18 = default(CommonToken);
		CommonToken RCURLY20 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> formalList14 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> typeName17 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr19 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> localOrFieldInit21 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree ID12_tree = default(CommonTree);
		CommonTree LPAREN13_tree = default(CommonTree);
		CommonTree RPAREN15_tree = default(CommonTree);
		CommonTree COLON16_tree = default(CommonTree);
		CommonTree LCURLY18_tree = default(CommonTree);
		CommonTree RCURLY20_tree = default(CommonTree);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_LCURLY=new RewriteRuleITokenStream(adaptor,"token LCURLY");
		RewriteRuleITokenStream stream_RCURLY=new RewriteRuleITokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_formalList=new RewriteRuleSubtreeStream(adaptor,"rule formalList");
		RewriteRuleSubtreeStream stream_typeName=new RewriteRuleSubtreeStream(adaptor,"rule typeName");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "feature");
		DebugLocation(54, 22);
		try
		{
			// CK.g:54:8: ( ( ID LPAREN ( formalList )? RPAREN COLON typeName LCURLY expr RCURLY ) -> ^( FuncDef ID typeName expr ( formalList )? ) | localOrFieldInit )
			int alt5=2;
			try { DebugEnterDecision(5, false);
			int LA5_1 = input.LA(1);

			if ((LA5_1==ID))
			{
				int LA5_2 = input.LA(2);

				if ((LA5_2==LPAREN))
				{
					alt5 = 1;
				}
				else if ((LA5_2==COLON))
				{
					alt5 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 5, 1, input, 2);
					DebugRecognitionException(nvae);
					//throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 5, 0, input, 1);
				DebugRecognitionException(nvae);
				//throw nvae;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// CK.g:55:3: ( ID LPAREN ( formalList )? RPAREN COLON typeName LCURLY expr RCURLY )
				{
				DebugLocation(55, 3);
				// CK.g:55:3: ( ID LPAREN ( formalList )? RPAREN COLON typeName LCURLY expr RCURLY )
				DebugEnterAlt(1);
				// CK.g:55:4: ID LPAREN ( formalList )? RPAREN COLON typeName LCURLY expr RCURLY
				{
				DebugLocation(55, 4);
				ID12=(CommonToken)Match(input,ID,Follow._ID_in_feature235);  
				stream_ID.Add(ID12);

				DebugLocation(55, 7);
				LPAREN13=(CommonToken)Match(input,LPAREN,Follow._LPAREN_in_feature237);  
				stream_LPAREN.Add(LPAREN13);

				DebugLocation(55, 14);
				// CK.g:55:14: ( formalList )?
				int alt4=2;
				try { DebugEnterSubRule(4);
				try { DebugEnterDecision(4, false);
				int LA4_1 = input.LA(1);

				if ((LA4_1==ID))
				{
					alt4 = 1;
				}
				} finally { DebugExitDecision(4); }
				switch (alt4)
				{
				case 1:
					DebugEnterAlt(1);
					// CK.g:55:15: formalList
					{
					DebugLocation(55, 15);
					PushFollow(Follow._formalList_in_feature240);
					formalList14=formalList();
					PopFollow();

					stream_formalList.Add(formalList14.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(4); }

				DebugLocation(55, 28);
				RPAREN15=(CommonToken)Match(input,RPAREN,Follow._RPAREN_in_feature244);  
				stream_RPAREN.Add(RPAREN15);

				DebugLocation(55, 35);
				COLON16=(CommonToken)Match(input,COLON,Follow._COLON_in_feature246);  
				stream_COLON.Add(COLON16);

				DebugLocation(55, 41);
				PushFollow(Follow._typeName_in_feature248);
				typeName17=typeName();
				PopFollow();

				stream_typeName.Add(typeName17.Tree);
				DebugLocation(55, 50);
				LCURLY18=(CommonToken)Match(input,LCURLY,Follow._LCURLY_in_feature250);  
				stream_LCURLY.Add(LCURLY18);

				DebugLocation(55, 57);
				PushFollow(Follow._expr_in_feature252);
				expr19=expr();
				PopFollow();

				stream_expr.Add(expr19.Tree);
				DebugLocation(55, 62);
				RCURLY20=(CommonToken)Match(input,RCURLY,Follow._RCURLY_in_feature254);  
				stream_RCURLY.Add(RCURLY20);


				}



				{
				// AST REWRITE
				// elements: ID, typeName, expr, formalList
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 55:70: -> ^( FuncDef ID typeName expr ( formalList )? )
				{
					DebugLocation(56, 4);
					// CK.g:56:4: ^( FuncDef ID typeName expr ( formalList )? )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(56, 6);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FuncDef, "FuncDef"), root_1);

					DebugLocation(56, 14);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(56, 17);
					adaptor.AddChild(root_1, stream_typeName.NextTree());
					DebugLocation(56, 26);
					adaptor.AddChild(root_1, stream_expr.NextTree());
					DebugLocation(56, 31);
					// CK.g:56:31: ( formalList )?
					if (stream_formalList.HasNext)
					{
						DebugLocation(56, 31);
						adaptor.AddChild(root_1, stream_formalList.NextTree());

					}
					stream_formalList.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// CK.g:57:6: localOrFieldInit
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(57, 6);
				PushFollow(Follow._localOrFieldInit_in_feature281);
				localOrFieldInit21=localOrFieldInit();
				PopFollow();

				adaptor.AddChild(root_0, localOrFieldInit21.Tree);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("feature", 4);
			LeaveRule("feature", 4);
			LeaveRule_feature();
		}
		DebugLocation(57, 22);
		} finally { DebugExitRule(GrammarFileName, "feature"); }
		return retval;

	}
	// $ANTLR end "feature"

	partial void EnterRule_formalList();
	partial void LeaveRule_formalList();
	// $ANTLR start "formalList"
	// CK.g:59:1: formalList : formal ( COMMA formal )* -> ^( FunctionArgsList ( formal )+ ) ;
	[GrammarRule("formalList")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> formalList()
	{
		EnterRule_formalList();
		EnterRule("formalList", 5);
		TraceIn("formalList", 5);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken COMMA23 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> formal22 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> formal24 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree COMMA23_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_formal=new RewriteRuleSubtreeStream(adaptor,"rule formal");
		try { DebugEnterRule(GrammarFileName, "formalList");
		DebugLocation(59, 54);
		try
		{
			// CK.g:59:11: ( formal ( COMMA formal )* -> ^( FunctionArgsList ( formal )+ ) )
			DebugEnterAlt(1);
			// CK.g:60:2: formal ( COMMA formal )*
			{
			DebugLocation(60, 2);
			PushFollow(Follow._formal_in_formalList290);
			formal22=formal();
			PopFollow();

			stream_formal.Add(formal22.Tree);
			DebugLocation(60, 9);
			// CK.g:60:9: ( COMMA formal )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_1 = input.LA(1);

				if ((LA6_1==COMMA))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// CK.g:60:10: COMMA formal
					{
					DebugLocation(60, 10);
					COMMA23=(CommonToken)Match(input,COMMA,Follow._COMMA_in_formalList293);  
					stream_COMMA.Add(COMMA23);

					DebugLocation(60, 16);
					PushFollow(Follow._formal_in_formalList295);
					formal24=formal();
					PopFollow();

					stream_formal.Add(formal24.Tree);

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }



			{
			// AST REWRITE
			// elements: formal
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 60:25: -> ^( FunctionArgsList ( formal )+ )
			{
				DebugLocation(60, 28);
				// CK.g:60:28: ^( FunctionArgsList ( formal )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(60, 30);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FunctionArgsList, "FunctionArgsList"), root_1);

				DebugLocation(60, 47);
				if (!(stream_formal.HasNext))
                {
                    DebugRecognitionException(new RewriteEarlyExitException());
					//throw new RewriteEarlyExitException();
				}
				while ( stream_formal.HasNext )
				{
					DebugLocation(60, 47);
					adaptor.AddChild(root_1, stream_formal.NextTree());

				}
				stream_formal.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("formalList", 5);
			LeaveRule("formalList", 5);
			LeaveRule_formalList();
		}
		DebugLocation(60, 54);
		} finally { DebugExitRule(GrammarFileName, "formalList"); }
		return retval;

	}
	// $ANTLR end "formalList"

	partial void EnterRule_formal();
	partial void LeaveRule_formal();
	// $ANTLR start "formal"
	// CK.g:62:1: formal : ID COLON ^ typeName ;
	[GrammarRule("formal")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> formal()
	{
		EnterRule_formal();
		EnterRule("formal", 6);
		TraceIn("formal", 6);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken ID25 = default(CommonToken);
		CommonToken COLON26 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> typeName27 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree ID25_tree = default(CommonTree);
		CommonTree COLON26_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "formal");
		DebugLocation(62, 26);
		try
		{
			// CK.g:62:7: ( ID COLON ^ typeName )
			DebugEnterAlt(1);
			// CK.g:62:9: ID COLON ^ typeName
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(62, 9);
			ID25=(CommonToken)Match(input,ID,Follow._ID_in_formal313); 
			ID25_tree = (CommonTree)adaptor.Create(ID25);
			adaptor.AddChild(root_0, ID25_tree);
			DebugLocation(62, 17);
			COLON26=(CommonToken)Match(input,COLON,Follow._COLON_in_formal315); 
			COLON26_tree = (CommonTree)adaptor.Create(COLON26);
			root_0 = (CommonTree)adaptor.BecomeRoot(COLON26_tree, root_0);
			DebugLocation(62, 19);
			PushFollow(Follow._typeName_in_formal318);
			typeName27=typeName();
			PopFollow();

			adaptor.AddChild(root_0, typeName27.Tree);

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("formal", 6);
			LeaveRule("formal", 6);
			LeaveRule_formal();
		}
		DebugLocation(62, 26);
		} finally { DebugExitRule(GrammarFileName, "formal"); }
		return retval;

	}
	// $ANTLR end "formal"

	partial void EnterRule_expr();
	partial void LeaveRule_expr();
	// $ANTLR start "expr"
	// CK.g:64:1: expr : ( ID ASSIGN ^)* not ;
	[GrammarRule("expr")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> expr()
	{
		EnterRule_expr();
		EnterRule("expr", 7);
		TraceIn("expr", 7);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken ID28 = default(CommonToken);
		CommonToken ASSIGN29 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> not30 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree ID28_tree = default(CommonTree);
		CommonTree ASSIGN29_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(64, 18);
		try
		{
			// CK.g:64:5: ( ( ID ASSIGN ^)* not )
			DebugEnterAlt(1);
			// CK.g:65:2: ( ID ASSIGN ^)* not
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(65, 2);
			// CK.g:65:2: ( ID ASSIGN ^)*
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				int LA7_1 = input.LA(1);

				if ((LA7_1==ID))
				{
					int LA7_2 = input.LA(2);

					if ((LA7_2==ASSIGN))
					{
						alt7 = 1;
					}


				}


				} finally { DebugExitDecision(7); }
				switch ( alt7 )
				{
				case 1:
					DebugEnterAlt(1);
					// CK.g:65:3: ID ASSIGN ^
					{
					DebugLocation(65, 3);
					ID28=(CommonToken)Match(input,ID,Follow._ID_in_expr327); 
					ID28_tree = (CommonTree)adaptor.Create(ID28);
					adaptor.AddChild(root_0, ID28_tree);
					DebugLocation(65, 12);
					ASSIGN29=(CommonToken)Match(input,ASSIGN,Follow._ASSIGN_in_expr329); 
					ASSIGN29_tree = (CommonTree)adaptor.Create(ASSIGN29);
					root_0 = (CommonTree)adaptor.BecomeRoot(ASSIGN29_tree, root_0);

					}
					break;

				default:
					goto loop7;
				}
			}

			loop7:
				;

			} finally { DebugExitSubRule(7); }

			DebugLocation(65, 16);
			PushFollow(Follow._not_in_expr334);
			not30=not();
			PopFollow();

			adaptor.AddChild(root_0, not30.Tree);

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("expr", 7);
			LeaveRule("expr", 7);
			LeaveRule_expr();
		}
		DebugLocation(65, 18);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return retval;

	}
	// $ANTLR end "expr"

	partial void EnterRule_not();
	partial void LeaveRule_not();
	// $ANTLR start "not"
	// CK.g:67:1: not : ( NOT ^)* relation ;
	[GrammarRule("not")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> not()
	{
		EnterRule_not();
		EnterRule("not", 8);
		TraceIn("not", 8);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken NOT31 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> relation32 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree NOT31_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "not");
		DebugLocation(67, 17);
		try
		{
			// CK.g:67:4: ( ( NOT ^)* relation )
			DebugEnterAlt(1);
			// CK.g:68:2: ( NOT ^)* relation
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(68, 2);
			// CK.g:68:2: ( NOT ^)*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_1 = input.LA(1);

				if ((LA8_1==NOT))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// CK.g:68:3: NOT ^
					{
					DebugLocation(68, 6);
					NOT31=(CommonToken)Match(input,NOT,Follow._NOT_in_not345); 
					NOT31_tree = (CommonTree)adaptor.Create(NOT31);
					root_0 = (CommonTree)adaptor.BecomeRoot(NOT31_tree, root_0);

					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }

			DebugLocation(68, 10);
			PushFollow(Follow._relation_in_not350);
			relation32=relation();
			PopFollow();

			adaptor.AddChild(root_0, relation32.Tree);

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("not", 8);
			LeaveRule("not", 8);
			LeaveRule_not();
		}
		DebugLocation(68, 17);
		} finally { DebugExitRule(GrammarFileName, "not"); }
		return retval;

	}
	// $ANTLR end "not"

	partial void EnterRule_relation();
	partial void LeaveRule_relation();
	// $ANTLR start "relation"
	// CK.g:70:1: relation : addition ( ( LE ^| LT ^| GE ^| GT ^| EQUAL ^) addition )* ;
	[GrammarRule("relation")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> relation()
	{
		EnterRule_relation();
		EnterRule("relation", 9);
		TraceIn("relation", 9);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken LE34 = default(CommonToken);
		CommonToken LT35 = default(CommonToken);
		CommonToken GE36 = default(CommonToken);
		CommonToken GT37 = default(CommonToken);
		CommonToken EQUAL38 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> addition33 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> addition39 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree LE34_tree = default(CommonTree);
		CommonTree LT35_tree = default(CommonTree);
		CommonTree GE36_tree = default(CommonTree);
		CommonTree GT37_tree = default(CommonTree);
		CommonTree EQUAL38_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "relation");
		DebugLocation(70, 54);
		try
		{
			// CK.g:70:9: ( addition ( ( LE ^| LT ^| GE ^| GT ^| EQUAL ^) addition )* )
			DebugEnterAlt(1);
			// CK.g:71:2: addition ( ( LE ^| LT ^| GE ^| GT ^| EQUAL ^) addition )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(71, 2);
			PushFollow(Follow._addition_in_relation359);
			addition33=addition();
			PopFollow();

			adaptor.AddChild(root_0, addition33.Tree);
			DebugLocation(71, 11);
			// CK.g:71:11: ( ( LE ^| LT ^| GE ^| GT ^| EQUAL ^) addition )*
			try { DebugEnterSubRule(10);
			while (true)
			{
				int alt10=2;
				try { DebugEnterDecision(10, false);
				int LA10_1 = input.LA(1);

				if ((LA10_1==EQUAL||(LA10_1>=GE && LA10_1<=GT)||LA10_1==LE||LA10_1==LT))
				{
					alt10 = 1;
				}


				} finally { DebugExitDecision(10); }
				switch ( alt10 )
				{
				case 1:
					DebugEnterAlt(1);
					// CK.g:71:12: ( LE ^| LT ^| GE ^| GT ^| EQUAL ^) addition
					{
					DebugLocation(71, 12);
					// CK.g:71:12: ( LE ^| LT ^| GE ^| GT ^| EQUAL ^)
					int alt9=5;
					try { DebugEnterSubRule(9);
					try { DebugEnterDecision(9, false);
					switch (input.LA(1))
					{
					case LE:
						{
						alt9 = 1;
						}
						break;
					case LT:
						{
						alt9 = 2;
						}
						break;
					case GE:
						{
						alt9 = 3;
						}
						break;
					case GT:
						{
						alt9 = 4;
						}
						break;
					case EQUAL:
						{
						alt9 = 5;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 9, 0, input, 1);
							DebugRecognitionException(nvae);
                            break;
							//throw nvae;
						}
					}

					} finally { DebugExitDecision(9); }
					switch (alt9)
					{
					case 1:
						DebugEnterAlt(1);
						// CK.g:71:13: LE ^
						{
						DebugLocation(71, 15);
						LE34=(CommonToken)Match(input,LE,Follow._LE_in_relation363); 
						LE34_tree = (CommonTree)adaptor.Create(LE34);
						root_0 = (CommonTree)adaptor.BecomeRoot(LE34_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// CK.g:71:19: LT ^
						{
						DebugLocation(71, 21);
						LT35=(CommonToken)Match(input,LT,Follow._LT_in_relation368); 
						LT35_tree = (CommonTree)adaptor.Create(LT35);
						root_0 = (CommonTree)adaptor.BecomeRoot(LT35_tree, root_0);

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// CK.g:71:25: GE ^
						{
						DebugLocation(71, 27);
						GE36=(CommonToken)Match(input,GE,Follow._GE_in_relation373); 
						GE36_tree = (CommonTree)adaptor.Create(GE36);
						root_0 = (CommonTree)adaptor.BecomeRoot(GE36_tree, root_0);

						}
						break;
					case 4:
						DebugEnterAlt(4);
						// CK.g:71:31: GT ^
						{
						DebugLocation(71, 33);
						GT37=(CommonToken)Match(input,GT,Follow._GT_in_relation378); 
						GT37_tree = (CommonTree)adaptor.Create(GT37);
						root_0 = (CommonTree)adaptor.BecomeRoot(GT37_tree, root_0);

						}
						break;
					case 5:
						DebugEnterAlt(5);
						// CK.g:71:37: EQUAL ^
						{
						DebugLocation(71, 42);
						EQUAL38=(CommonToken)Match(input,EQUAL,Follow._EQUAL_in_relation383); 
						EQUAL38_tree = (CommonTree)adaptor.Create(EQUAL38);
						root_0 = (CommonTree)adaptor.BecomeRoot(EQUAL38_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(9); }

					DebugLocation(71, 45);
					PushFollow(Follow._addition_in_relation387);
					addition39=addition();
					PopFollow();

					adaptor.AddChild(root_0, addition39.Tree);

					}
					break;

				default:
					goto loop10;
				}
			}

			loop10:
				;

			} finally { DebugExitSubRule(10); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("relation", 9);
			LeaveRule("relation", 9);
			LeaveRule_relation();
		}
		DebugLocation(71, 54);
		} finally { DebugExitRule(GrammarFileName, "relation"); }
		return retval;

	}
	// $ANTLR end "relation"

	partial void EnterRule_addition();
	partial void LeaveRule_addition();
	// $ANTLR start "addition"
	// CK.g:73:1: addition : multiplication ( ( PLUS ^| MINUS ^) multiplication )* ;
	[GrammarRule("addition")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> addition()
	{
		EnterRule_addition();
		EnterRule("addition", 10);
		TraceIn("addition", 10);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken PLUS41 = default(CommonToken);
		CommonToken MINUS42 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> multiplication40 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> multiplication43 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree PLUS41_tree = default(CommonTree);
		CommonTree MINUS42_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "addition");
		DebugLocation(73, 50);
		try
		{
			// CK.g:73:9: ( multiplication ( ( PLUS ^| MINUS ^) multiplication )* )
			DebugEnterAlt(1);
			// CK.g:74:2: multiplication ( ( PLUS ^| MINUS ^) multiplication )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(74, 2);
			PushFollow(Follow._multiplication_in_addition398);
			multiplication40=multiplication();
			PopFollow();

			adaptor.AddChild(root_0, multiplication40.Tree);
			DebugLocation(74, 17);
			// CK.g:74:17: ( ( PLUS ^| MINUS ^) multiplication )*
			try { DebugEnterSubRule(12);
			while (true)
			{
				int alt12=2;
				try { DebugEnterDecision(12, false);
				int LA12_1 = input.LA(1);

				if ((LA12_1==MINUS||LA12_1==PLUS))
				{
					alt12 = 1;
				}


				} finally { DebugExitDecision(12); }
				switch ( alt12 )
				{
				case 1:
					DebugEnterAlt(1);
					// CK.g:74:18: ( PLUS ^| MINUS ^) multiplication
					{
					DebugLocation(74, 18);
					// CK.g:74:18: ( PLUS ^| MINUS ^)
					int alt11=2;
					try { DebugEnterSubRule(11);
					try { DebugEnterDecision(11, false);
					int LA11_1 = input.LA(1);

					if ((LA11_1==PLUS))
					{
						alt11 = 1;
					}
					else if ((LA11_1==MINUS))
					{
						alt11 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 11, 0, input, 1);
						DebugRecognitionException(nvae);
						//throw nvae;
					}
					} finally { DebugExitDecision(11); }
					switch (alt11)
					{
					case 1:
						DebugEnterAlt(1);
						// CK.g:74:19: PLUS ^
						{
						DebugLocation(74, 23);
						PLUS41=(CommonToken)Match(input,PLUS,Follow._PLUS_in_addition402); 
						PLUS41_tree = (CommonTree)adaptor.Create(PLUS41);
						root_0 = (CommonTree)adaptor.BecomeRoot(PLUS41_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// CK.g:74:27: MINUS ^
						{
						DebugLocation(74, 32);
						MINUS42=(CommonToken)Match(input,MINUS,Follow._MINUS_in_addition407); 
						MINUS42_tree = (CommonTree)adaptor.Create(MINUS42);
						root_0 = (CommonTree)adaptor.BecomeRoot(MINUS42_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(11); }

					DebugLocation(74, 35);
					PushFollow(Follow._multiplication_in_addition411);
					multiplication43=multiplication();
					PopFollow();

					adaptor.AddChild(root_0, multiplication43.Tree);

					}
					break;

				default:
					goto loop12;
				}
			}

			loop12:
				;

			} finally { DebugExitSubRule(12); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("addition", 10);
			LeaveRule("addition", 10);
			LeaveRule_addition();
		}
		DebugLocation(74, 50);
		} finally { DebugExitRule(GrammarFileName, "addition"); }
		return retval;

	}
	// $ANTLR end "addition"

	partial void EnterRule_multiplication();
	partial void LeaveRule_multiplication();
	// $ANTLR start "multiplication"
	// CK.g:76:1: multiplication : isvoid ( ( MULT ^| DIV ^) isvoid )* ;
	[GrammarRule("multiplication")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> multiplication()
	{
		EnterRule_multiplication();
		EnterRule("multiplication", 11);
		TraceIn("multiplication", 11);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken MULT45 = default(CommonToken);
		CommonToken DIV46 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> isvoid44 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> isvoid47 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree MULT45_tree = default(CommonTree);
		CommonTree DIV46_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "multiplication");
		DebugLocation(76, 32);
		try
		{
			// CK.g:76:15: ( isvoid ( ( MULT ^| DIV ^) isvoid )* )
			DebugEnterAlt(1);
			// CK.g:77:2: isvoid ( ( MULT ^| DIV ^) isvoid )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(77, 2);
			PushFollow(Follow._isvoid_in_multiplication421);
			isvoid44=isvoid();
			PopFollow();

			adaptor.AddChild(root_0, isvoid44.Tree);
			DebugLocation(77, 9);
			// CK.g:77:9: ( ( MULT ^| DIV ^) isvoid )*
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=2;
				try { DebugEnterDecision(14, false);
				int LA14_1 = input.LA(1);

				if ((LA14_1==DIV||LA14_1==MULT))
				{
					alt14 = 1;
				}


				} finally { DebugExitDecision(14); }
				switch ( alt14 )
				{
				case 1:
					DebugEnterAlt(1);
					// CK.g:77:10: ( MULT ^| DIV ^) isvoid
					{
					DebugLocation(77, 10);
					// CK.g:77:10: ( MULT ^| DIV ^)
					int alt13=2;
					try { DebugEnterSubRule(13);
					try { DebugEnterDecision(13, false);
					int LA13_1 = input.LA(1);

					if ((LA13_1==MULT))
					{
						alt13 = 1;
					}
					else if ((LA13_1==DIV))
					{
						alt13 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 13, 0, input, 1);
						DebugRecognitionException(nvae);
						//throw nvae;
					}
					} finally { DebugExitDecision(13); }
					switch (alt13)
					{
					case 1:
						DebugEnterAlt(1);
						// CK.g:77:11: MULT ^
						{
						DebugLocation(77, 15);
						MULT45=(CommonToken)Match(input,MULT,Follow._MULT_in_multiplication425); 
						MULT45_tree = (CommonTree)adaptor.Create(MULT45);
						root_0 = (CommonTree)adaptor.BecomeRoot(MULT45_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// CK.g:77:19: DIV ^
						{
						DebugLocation(77, 22);
						DIV46=(CommonToken)Match(input,DIV,Follow._DIV_in_multiplication430); 
						DIV46_tree = (CommonTree)adaptor.Create(DIV46);
						root_0 = (CommonTree)adaptor.BecomeRoot(DIV46_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(13); }

					DebugLocation(77, 25);
					PushFollow(Follow._isvoid_in_multiplication434);
					isvoid47=isvoid();
					PopFollow();

					adaptor.AddChild(root_0, isvoid47.Tree);

					}
					break;

				default:
					goto loop14;
				}
			}

			loop14:
				;

			} finally { DebugExitSubRule(14); }


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("multiplication", 11);
			LeaveRule("multiplication", 11);
			LeaveRule_multiplication();
		}
		DebugLocation(77, 32);
		} finally { DebugExitRule(GrammarFileName, "multiplication"); }
		return retval;

	}
	// $ANTLR end "multiplication"

	partial void EnterRule_isvoid();
	partial void LeaveRule_isvoid();
	// $ANTLR start "isvoid"
	// CK.g:79:1: isvoid : ( ISVOID ^)* neg ;
	[GrammarRule("isvoid")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> isvoid()
	{
		EnterRule_isvoid();
		EnterRule("isvoid", 12);
		TraceIn("isvoid", 12);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken ISVOID48 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> neg49 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree ISVOID48_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "isvoid");
		DebugLocation(79, 15);
		try
		{
			// CK.g:79:7: ( ( ISVOID ^)* neg )
			DebugEnterAlt(1);
			// CK.g:80:2: ( ISVOID ^)* neg
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(80, 2);
			// CK.g:80:2: ( ISVOID ^)*
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=2;
				try { DebugEnterDecision(15, false);
				int LA15_1 = input.LA(1);

				if ((LA15_1==ISVOID))
				{
					alt15 = 1;
				}


				} finally { DebugExitDecision(15); }
				switch ( alt15 )
				{
				case 1:
					DebugEnterAlt(1);
					// CK.g:80:3: ISVOID ^
					{
					DebugLocation(80, 9);
					ISVOID48=(CommonToken)Match(input,ISVOID,Follow._ISVOID_in_isvoid445); 
					ISVOID48_tree = (CommonTree)adaptor.Create(ISVOID48);
					root_0 = (CommonTree)adaptor.BecomeRoot(ISVOID48_tree, root_0);

					}
					break;

				default:
					goto loop15;
				}
			}

			loop15:
				;

			} finally { DebugExitSubRule(15); }

			DebugLocation(80, 13);
			PushFollow(Follow._neg_in_isvoid450);
			neg49=neg();
			PopFollow();

			adaptor.AddChild(root_0, neg49.Tree);

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("isvoid", 12);
			LeaveRule("isvoid", 12);
			LeaveRule_isvoid();
		}
		DebugLocation(80, 15);
		} finally { DebugExitRule(GrammarFileName, "isvoid"); }
		return retval;

	}
	// $ANTLR end "isvoid"

	partial void EnterRule_neg();
	partial void LeaveRule_neg();
	// $ANTLR start "neg"
	// CK.g:82:1: neg : ( NEG ^)* dot ;
	[GrammarRule("neg")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> neg()
	{
		EnterRule_neg();
		EnterRule("neg", 13);
		TraceIn("neg", 13);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken NEG50 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> dot51 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree NEG50_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "neg");
		DebugLocation(82, 12);
		try
		{
			// CK.g:82:4: ( ( NEG ^)* dot )
			DebugEnterAlt(1);
			// CK.g:83:2: ( NEG ^)* dot
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(83, 2);
			// CK.g:83:2: ( NEG ^)*
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=2;
				try { DebugEnterDecision(16, false);
				int LA16_1 = input.LA(1);

				if ((LA16_1==NEG))
				{
					alt16 = 1;
				}


				} finally { DebugExitDecision(16); }
				switch ( alt16 )
				{
				case 1:
					DebugEnterAlt(1);
					// CK.g:83:3: NEG ^
					{
					DebugLocation(83, 6);
					NEG50=(CommonToken)Match(input,NEG,Follow._NEG_in_neg459); 
					NEG50_tree = (CommonTree)adaptor.Create(NEG50);
					root_0 = (CommonTree)adaptor.BecomeRoot(NEG50_tree, root_0);

					}
					break;

				default:
					goto loop16;
				}
			}

			loop16:
				;

			} finally { DebugExitSubRule(16); }

			DebugLocation(83, 10);
			PushFollow(Follow._dot_in_neg464);
			dot51=dot();
			PopFollow();

			adaptor.AddChild(root_0, dot51.Tree);

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("neg", 13);
			LeaveRule("neg", 13);
			LeaveRule_neg();
		}
		DebugLocation(83, 12);
		} finally { DebugExitRule(GrammarFileName, "neg"); }
		return retval;

	}
	// $ANTLR end "neg"

	partial void EnterRule_dot();
	partial void LeaveRule_dot();
	// $ANTLR start "dot"
	// CK.g:88:1: dot : term ( DOT ID LPAREN ( invokeExprs )? RPAREN )? -> ^( Term term ( ID )? ( invokeExprs )? ) ;
	[GrammarRule("dot")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> dot()
	{
		EnterRule_dot();
		EnterRule("dot", 14);
		TraceIn("dot", 14);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken DOT53 = default(CommonToken);
		CommonToken ID54 = default(CommonToken);
		CommonToken LPAREN55 = default(CommonToken);
		CommonToken RPAREN57 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> term52 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> invokeExprs56 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree DOT53_tree = default(CommonTree);
		CommonTree ID54_tree = default(CommonTree);
		CommonTree LPAREN55_tree = default(CommonTree);
		CommonTree RPAREN57_tree = default(CommonTree);
		RewriteRuleITokenStream stream_DOT=new RewriteRuleITokenStream(adaptor,"token DOT");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_term=new RewriteRuleSubtreeStream(adaptor,"rule term");
		RewriteRuleSubtreeStream stream_invokeExprs=new RewriteRuleSubtreeStream(adaptor,"rule invokeExprs");
		try { DebugEnterRule(GrammarFileName, "dot");
		DebugLocation(88, 31);
		try
		{
			// CK.g:88:4: ( term ( DOT ID LPAREN ( invokeExprs )? RPAREN )? -> ^( Term term ( ID )? ( invokeExprs )? ) )
			DebugEnterAlt(1);
			// CK.g:89:2: term ( DOT ID LPAREN ( invokeExprs )? RPAREN )?
			{
			DebugLocation(89, 2);
			PushFollow(Follow._term_in_dot476);
			term52=term();
			PopFollow();

			stream_term.Add(term52.Tree);
			DebugLocation(89, 7);
			// CK.g:89:7: ( DOT ID LPAREN ( invokeExprs )? RPAREN )?
			int alt18=2;
			try { DebugEnterSubRule(18);
			try { DebugEnterDecision(18, false);
			int LA18_1 = input.LA(1);

			if ((LA18_1==DOT))
			{
				alt18 = 1;
			}
			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// CK.g:89:8: DOT ID LPAREN ( invokeExprs )? RPAREN
				{
				DebugLocation(89, 8);
				DOT53=(CommonToken)Match(input,DOT,Follow._DOT_in_dot479);  
				stream_DOT.Add(DOT53);

				DebugLocation(89, 12);
				ID54=(CommonToken)Match(input,ID,Follow._ID_in_dot481);  
				stream_ID.Add(ID54);

				DebugLocation(89, 15);
				LPAREN55=(CommonToken)Match(input,LPAREN,Follow._LPAREN_in_dot483);  
				stream_LPAREN.Add(LPAREN55);

				DebugLocation(89, 22);
				// CK.g:89:22: ( invokeExprs )?
				int alt17=2;
				try { DebugEnterSubRule(17);
				try { DebugEnterDecision(17, false);
				int LA17_1 = input.LA(1);

				if ((LA17_1==CHAR||(LA17_1>=FALSE && LA17_1<=FLOAT)||(LA17_1>=ID && LA17_1<=ISVOID)||LA17_1==LCURLY||LA17_1==LPAREN||(LA17_1>=NEG && LA17_1<=NOT)||LA17_1==RETURN||LA17_1==STRING||LA17_1==TRUE||(LA17_1>=VAR && LA17_1<=VOID)||LA17_1==WHILE))
				{
					alt17 = 1;
				}
				} finally { DebugExitDecision(17); }
				switch (alt17)
				{
				case 1:
					DebugEnterAlt(1);
					// CK.g:89:22: invokeExprs
					{
					DebugLocation(89, 22);
					PushFollow(Follow._invokeExprs_in_dot485);
					invokeExprs56=invokeExprs();
					PopFollow();

					stream_invokeExprs.Add(invokeExprs56.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(17); }

				DebugLocation(89, 35);
				RPAREN57=(CommonToken)Match(input,RPAREN,Follow._RPAREN_in_dot488);  
				stream_RPAREN.Add(RPAREN57);


				}
				break;

			}
			} finally { DebugExitSubRule(18); }



			{
			// AST REWRITE
			// elements: term, ID, invokeExprs
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 89:44: -> ^( Term term ( ID )? ( invokeExprs )? )
			{
				DebugLocation(90, 3);
				// CK.g:90:3: ^( Term term ( ID )? ( invokeExprs )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(90, 5);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Term, "Term"), root_1);

				DebugLocation(90, 10);
				adaptor.AddChild(root_1, stream_term.NextTree());
				DebugLocation(90, 15);
				// CK.g:90:15: ( ID )?
				if (stream_ID.HasNext)
				{
					DebugLocation(90, 15);
					adaptor.AddChild(root_1, stream_ID.NextNode());

				}
				stream_ID.Reset();
				DebugLocation(90, 19);
				// CK.g:90:19: ( invokeExprs )?
				if (stream_invokeExprs.HasNext)
				{
					DebugLocation(90, 19);
					adaptor.AddChild(root_1, stream_invokeExprs.NextTree());

				}
				stream_invokeExprs.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("dot", 14);
			LeaveRule("dot", 14);
			LeaveRule_dot();
		}
		DebugLocation(90, 31);
		} finally { DebugExitRule(GrammarFileName, "dot"); }
		return retval;

	}
	// $ANTLR end "dot"

	partial void EnterRule_term();
	partial void LeaveRule_term();
	// $ANTLR start "term"
	// CK.g:92:1: term : ( ID LPAREN ( invokeExprs )? RPAREN -> ^( ImplicitInvoke ID ( invokeExprs )? ) | IF ^ expr THEN ! expr ELSE ! expr ENDIF !| WHILE ^ expr LOOP ! expr ENDLOOP !| LCURLY ( expr SEMI )+ RCURLY -> ^( Exprs ( expr )+ ) | VAR ^ varExprs SEMI !| NEW ^ typeName SEMI !| RETURN ^ expr SEMI !| LPAREN expr RPAREN -> ^( Expr expr ) | ID ^| INTEGER ^| FLOAT ^| STRING ^| CHAR ^| TRUE ^| FALSE ^| VOID ^);
	[GrammarRule("term")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> term()
	{
		EnterRule_term();
		EnterRule("term", 15);
		TraceIn("term", 15);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken ID58 = default(CommonToken);
		CommonToken LPAREN59 = default(CommonToken);
		CommonToken RPAREN61 = default(CommonToken);
		CommonToken IF62 = default(CommonToken);
		CommonToken THEN64 = default(CommonToken);
		CommonToken ELSE66 = default(CommonToken);
		CommonToken ENDIF68 = default(CommonToken);
		CommonToken WHILE69 = default(CommonToken);
		CommonToken LOOP71 = default(CommonToken);
		CommonToken ENDLOOP73 = default(CommonToken);
		CommonToken LCURLY74 = default(CommonToken);
		CommonToken SEMI76 = default(CommonToken);
		CommonToken RCURLY77 = default(CommonToken);
		CommonToken VAR78 = default(CommonToken);
		CommonToken SEMI80 = default(CommonToken);
		CommonToken NEW81 = default(CommonToken);
		CommonToken SEMI83 = default(CommonToken);
		CommonToken RETURN84 = default(CommonToken);
		CommonToken SEMI86 = default(CommonToken);
		CommonToken LPAREN87 = default(CommonToken);
		CommonToken RPAREN89 = default(CommonToken);
		CommonToken ID90 = default(CommonToken);
		CommonToken INTEGER91 = default(CommonToken);
		CommonToken FLOAT92 = default(CommonToken);
		CommonToken STRING93 = default(CommonToken);
		CommonToken CHAR94 = default(CommonToken);
		CommonToken TRUE95 = default(CommonToken);
		CommonToken FALSE96 = default(CommonToken);
		CommonToken VOID97 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> invokeExprs60 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr63 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr65 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr67 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr70 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr72 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr75 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> varExprs79 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> typeName82 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr85 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr88 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree ID58_tree = default(CommonTree);
		CommonTree LPAREN59_tree = default(CommonTree);
		CommonTree RPAREN61_tree = default(CommonTree);
		CommonTree IF62_tree = default(CommonTree);
		CommonTree THEN64_tree = default(CommonTree);
		CommonTree ELSE66_tree = default(CommonTree);
		CommonTree ENDIF68_tree = default(CommonTree);
		CommonTree WHILE69_tree = default(CommonTree);
		CommonTree LOOP71_tree = default(CommonTree);
		CommonTree ENDLOOP73_tree = default(CommonTree);
		CommonTree LCURLY74_tree = default(CommonTree);
		CommonTree SEMI76_tree = default(CommonTree);
		CommonTree RCURLY77_tree = default(CommonTree);
		CommonTree VAR78_tree = default(CommonTree);
		CommonTree SEMI80_tree = default(CommonTree);
		CommonTree NEW81_tree = default(CommonTree);
		CommonTree SEMI83_tree = default(CommonTree);
		CommonTree RETURN84_tree = default(CommonTree);
		CommonTree SEMI86_tree = default(CommonTree);
		CommonTree LPAREN87_tree = default(CommonTree);
		CommonTree RPAREN89_tree = default(CommonTree);
		CommonTree ID90_tree = default(CommonTree);
		CommonTree INTEGER91_tree = default(CommonTree);
		CommonTree FLOAT92_tree = default(CommonTree);
		CommonTree STRING93_tree = default(CommonTree);
		CommonTree CHAR94_tree = default(CommonTree);
		CommonTree TRUE95_tree = default(CommonTree);
		CommonTree FALSE96_tree = default(CommonTree);
		CommonTree VOID97_tree = default(CommonTree);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_LCURLY=new RewriteRuleITokenStream(adaptor,"token LCURLY");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleITokenStream stream_RCURLY=new RewriteRuleITokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_invokeExprs=new RewriteRuleSubtreeStream(adaptor,"rule invokeExprs");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "term");
		DebugLocation(92, 8);
		try
		{
			// CK.g:92:5: ( ID LPAREN ( invokeExprs )? RPAREN -> ^( ImplicitInvoke ID ( invokeExprs )? ) | IF ^ expr THEN ! expr ELSE ! expr ENDIF !| WHILE ^ expr LOOP ! expr ENDLOOP !| LCURLY ( expr SEMI )+ RCURLY -> ^( Exprs ( expr )+ ) | VAR ^ varExprs SEMI !| NEW ^ typeName SEMI !| RETURN ^ expr SEMI !| LPAREN expr RPAREN -> ^( Expr expr ) | ID ^| INTEGER ^| FLOAT ^| STRING ^| CHAR ^| TRUE ^| FALSE ^| VOID ^)
			int alt21=16;
			try { DebugEnterDecision(21, false);
			switch (input.LA(1))
			{
			case ID:
				{
				int LA21_2 = input.LA(2);

				if ((LA21_2==LPAREN))
				{
					alt21 = 1;
				}
				else if ((LA21_2==COMMA||(LA21_2>=DIV && LA21_2<=EQUAL)||(LA21_2>=GE && LA21_2<=GT)||LA21_2==LE||LA21_2==LOOP||LA21_2==LT||(LA21_2>=MINUS && LA21_2<=MULT)||(LA21_2>=PLUS && LA21_2<=RCURLY)||(LA21_2>=RPAREN && LA21_2<=SEMI)||LA21_2==THEN))
				{
					alt21 = 9;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 21, 1, input, 2);
					DebugRecognitionException(nvae);
					//throw nvae;
				}
				}
				break;
			case IF:
				{
				alt21 = 2;
				}
				break;
			case WHILE:
				{
				alt21 = 3;
				}
				break;
			case LCURLY:
				{
				alt21 = 4;
				}
				break;
			case VAR:
				{
				alt21 = 5;
				}
				break;
			case NEW:
				{
				alt21 = 6;
				}
				break;
			case RETURN:
				{
				alt21 = 7;
				}
				break;
			case LPAREN:
				{
				alt21 = 8;
				}
				break;
			case INTEGER:
				{
				alt21 = 10;
				}
				break;
			case FLOAT:
				{
				alt21 = 11;
				}
				break;
			case STRING:
				{
				alt21 = 12;
				}
				break;
			case CHAR:
				{
				alt21 = 13;
				}
				break;
			case TRUE:
				{
				alt21 = 14;
				}
				break;
			case FALSE:
				{
				alt21 = 15;
				}
				break;
			case VOID:
				{
				alt21 = 16;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 21, 0, input, 1);
					DebugRecognitionException(nvae);
                    break;
					//throw nvae;
				}
			}

			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// CK.g:93:4: ID LPAREN ( invokeExprs )? RPAREN
				{
				DebugLocation(93, 4);
				ID58=(CommonToken)Match(input,ID,Follow._ID_in_term516);  
				stream_ID.Add(ID58);

				DebugLocation(93, 7);
				LPAREN59=(CommonToken)Match(input,LPAREN,Follow._LPAREN_in_term518);  
				stream_LPAREN.Add(LPAREN59);

				DebugLocation(93, 14);
				// CK.g:93:14: ( invokeExprs )?
				int alt19=2;
				try { DebugEnterSubRule(19);
				try { DebugEnterDecision(19, false);
				int LA19_1 = input.LA(1);

				if ((LA19_1==CHAR||(LA19_1>=FALSE && LA19_1<=FLOAT)||(LA19_1>=ID && LA19_1<=ISVOID)||LA19_1==LCURLY||LA19_1==LPAREN||(LA19_1>=NEG && LA19_1<=NOT)||LA19_1==RETURN||LA19_1==STRING||LA19_1==TRUE||(LA19_1>=VAR && LA19_1<=VOID)||LA19_1==WHILE))
				{
					alt19 = 1;
				}
				} finally { DebugExitDecision(19); }
				switch (alt19)
				{
				case 1:
					DebugEnterAlt(1);
					// CK.g:93:14: invokeExprs
					{
					DebugLocation(93, 14);
					PushFollow(Follow._invokeExprs_in_term520);
					invokeExprs60=invokeExprs();
					PopFollow();

					stream_invokeExprs.Add(invokeExprs60.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(19); }

				DebugLocation(93, 27);
				RPAREN61=(CommonToken)Match(input,RPAREN,Follow._RPAREN_in_term523);  
				stream_RPAREN.Add(RPAREN61);



				{
				// AST REWRITE
				// elements: ID, invokeExprs
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 93:34: -> ^( ImplicitInvoke ID ( invokeExprs )? )
				{
					DebugLocation(93, 37);
					// CK.g:93:37: ^( ImplicitInvoke ID ( invokeExprs )? )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(93, 39);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ImplicitInvoke, "ImplicitInvoke"), root_1);

					DebugLocation(93, 54);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(93, 57);
					// CK.g:93:57: ( invokeExprs )?
					if (stream_invokeExprs.HasNext)
					{
						DebugLocation(93, 57);
						adaptor.AddChild(root_1, stream_invokeExprs.NextTree());

					}
					stream_invokeExprs.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// CK.g:94:4: IF ^ expr THEN ! expr ELSE ! expr ENDIF !
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(94, 6);
				IF62=(CommonToken)Match(input,IF,Follow._IF_in_term539); 
				IF62_tree = (CommonTree)adaptor.Create(IF62);
				root_0 = (CommonTree)adaptor.BecomeRoot(IF62_tree, root_0);
				DebugLocation(94, 8);
				PushFollow(Follow._expr_in_term542);
				expr63=expr();
				PopFollow();

				adaptor.AddChild(root_0, expr63.Tree);
				DebugLocation(94, 17);
				THEN64=(CommonToken)Match(input,THEN,Follow._THEN_in_term544); 
				DebugLocation(94, 19);
				PushFollow(Follow._expr_in_term547);
				expr65=expr();
				PopFollow();

				adaptor.AddChild(root_0, expr65.Tree);
				DebugLocation(94, 28);
				ELSE66=(CommonToken)Match(input,ELSE,Follow._ELSE_in_term549); 
				DebugLocation(94, 30);
				PushFollow(Follow._expr_in_term552);
				expr67=expr();
				PopFollow();

				adaptor.AddChild(root_0, expr67.Tree);
				DebugLocation(94, 40);
				ENDIF68=(CommonToken)Match(input,ENDIF,Follow._ENDIF_in_term554); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// CK.g:95:4: WHILE ^ expr LOOP ! expr ENDLOOP !
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(95, 9);
				WHILE69=(CommonToken)Match(input,WHILE,Follow._WHILE_in_term560); 
				WHILE69_tree = (CommonTree)adaptor.Create(WHILE69);
				root_0 = (CommonTree)adaptor.BecomeRoot(WHILE69_tree, root_0);
				DebugLocation(95, 11);
				PushFollow(Follow._expr_in_term563);
				expr70=expr();
				PopFollow();

				adaptor.AddChild(root_0, expr70.Tree);
				DebugLocation(95, 20);
				LOOP71=(CommonToken)Match(input,LOOP,Follow._LOOP_in_term565); 
				DebugLocation(95, 22);
				PushFollow(Follow._expr_in_term568);
				expr72=expr();
				PopFollow();

				adaptor.AddChild(root_0, expr72.Tree);
				DebugLocation(95, 34);
				ENDLOOP73=(CommonToken)Match(input,ENDLOOP,Follow._ENDLOOP_in_term570); 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// CK.g:96:4: LCURLY ( expr SEMI )+ RCURLY
				{
				DebugLocation(96, 4);
				LCURLY74=(CommonToken)Match(input,LCURLY,Follow._LCURLY_in_term576);  
				stream_LCURLY.Add(LCURLY74);

				DebugLocation(96, 11);
				// CK.g:96:11: ( expr SEMI )+
				int cnt20=0;
				try { DebugEnterSubRule(20);
				while (true)
				{
					int alt20=2;
					try { DebugEnterDecision(20, false);
					int LA20_1 = input.LA(1);

					if ((LA20_1==CHAR||(LA20_1>=FALSE && LA20_1<=FLOAT)||(LA20_1>=ID && LA20_1<=ISVOID)||LA20_1==LCURLY||LA20_1==LPAREN||(LA20_1>=NEG && LA20_1<=NOT)||LA20_1==RETURN||LA20_1==STRING||LA20_1==TRUE||(LA20_1>=VAR && LA20_1<=VOID)||LA20_1==WHILE))
					{
						alt20 = 1;
					}


					} finally { DebugExitDecision(20); }
					switch (alt20)
					{
					case 1:
						DebugEnterAlt(1);
						// CK.g:96:12: expr SEMI
						{
						DebugLocation(96, 12);
						PushFollow(Follow._expr_in_term579);
						expr75=expr();
						PopFollow();

						stream_expr.Add(expr75.Tree);
						DebugLocation(96, 17);
						SEMI76=(CommonToken)Match(input,SEMI,Follow._SEMI_in_term581);  
						stream_SEMI.Add(SEMI76);


						}
						break;

					default:
						if (cnt20 >= 1)
							goto loop20;

						EarlyExitException eee20 = new EarlyExitException( 20, input );
						DebugRecognitionException(eee20);
						//throw eee20;
                            break;
					}
					cnt20++;
				}
				loop20:
					;

				} finally { DebugExitSubRule(20); }

				DebugLocation(96, 24);
				RCURLY77=(CommonToken)Match(input,RCURLY,Follow._RCURLY_in_term585);  
				stream_RCURLY.Add(RCURLY77);



				{
				// AST REWRITE
				// elements: expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 96:31: -> ^( Exprs ( expr )+ )
				{
					DebugLocation(96, 34);
					// CK.g:96:34: ^( Exprs ( expr )+ )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(96, 36);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Exprs, "Exprs"), root_1);

					DebugLocation(96, 42);
					if (!(stream_expr.HasNext))
                    {
                        DebugRecognitionException(new RewriteEarlyExitException());
						//throw new RewriteEarlyExitException();
					}
					while ( stream_expr.HasNext )
					{
						DebugLocation(96, 42);
						adaptor.AddChild(root_1, stream_expr.NextTree());

					}
					stream_expr.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// CK.g:97:4: VAR ^ varExprs SEMI !
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(97, 7);
				VAR78=(CommonToken)Match(input,VAR,Follow._VAR_in_term599); 
				VAR78_tree = (CommonTree)adaptor.Create(VAR78);
				root_0 = (CommonTree)adaptor.BecomeRoot(VAR78_tree, root_0);
				DebugLocation(97, 9);
				PushFollow(Follow._varExprs_in_term602);
				varExprs79=varExprs();
				PopFollow();

				adaptor.AddChild(root_0, varExprs79.Tree);
				DebugLocation(97, 22);
				SEMI80=(CommonToken)Match(input,SEMI,Follow._SEMI_in_term604); 

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// CK.g:98:4: NEW ^ typeName SEMI !
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(98, 7);
				NEW81=(CommonToken)Match(input,NEW,Follow._NEW_in_term610); 
				NEW81_tree = (CommonTree)adaptor.Create(NEW81);
				root_0 = (CommonTree)adaptor.BecomeRoot(NEW81_tree, root_0);
				DebugLocation(98, 9);
				PushFollow(Follow._typeName_in_term613);
				typeName82=typeName();
				PopFollow();

				adaptor.AddChild(root_0, typeName82.Tree);
				DebugLocation(98, 22);
				SEMI83=(CommonToken)Match(input,SEMI,Follow._SEMI_in_term615); 

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// CK.g:99:4: RETURN ^ expr SEMI !
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(99, 10);
				RETURN84=(CommonToken)Match(input,RETURN,Follow._RETURN_in_term621); 
				RETURN84_tree = (CommonTree)adaptor.Create(RETURN84);
				root_0 = (CommonTree)adaptor.BecomeRoot(RETURN84_tree, root_0);
				DebugLocation(99, 12);
				PushFollow(Follow._expr_in_term624);
				expr85=expr();
				PopFollow();

				adaptor.AddChild(root_0, expr85.Tree);
				DebugLocation(99, 21);
				SEMI86=(CommonToken)Match(input,SEMI,Follow._SEMI_in_term626); 

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// CK.g:100:4: LPAREN expr RPAREN
				{
				DebugLocation(100, 4);
				LPAREN87=(CommonToken)Match(input,LPAREN,Follow._LPAREN_in_term632);  
				stream_LPAREN.Add(LPAREN87);

				DebugLocation(100, 11);
				PushFollow(Follow._expr_in_term634);
				expr88=expr();
				PopFollow();

				stream_expr.Add(expr88.Tree);
				DebugLocation(100, 16);
				RPAREN89=(CommonToken)Match(input,RPAREN,Follow._RPAREN_in_term636);  
				stream_RPAREN.Add(RPAREN89);



				{
				// AST REWRITE
				// elements: expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 100:23: -> ^( Expr expr )
				{
					DebugLocation(100, 26);
					// CK.g:100:26: ^( Expr expr )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(100, 28);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(Expr, "Expr"), root_1);

					DebugLocation(100, 33);
					adaptor.AddChild(root_1, stream_expr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// CK.g:101:4: ID ^
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(101, 6);
				ID90=(CommonToken)Match(input,ID,Follow._ID_in_term649); 
				ID90_tree = (CommonTree)adaptor.Create(ID90);
				root_0 = (CommonTree)adaptor.BecomeRoot(ID90_tree, root_0);

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// CK.g:102:4: INTEGER ^
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(102, 11);
				INTEGER91=(CommonToken)Match(input,INTEGER,Follow._INTEGER_in_term655); 
				INTEGER91_tree = (CommonTree)adaptor.Create(INTEGER91);
				root_0 = (CommonTree)adaptor.BecomeRoot(INTEGER91_tree, root_0);

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// CK.g:103:4: FLOAT ^
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(103, 9);
				FLOAT92=(CommonToken)Match(input,FLOAT,Follow._FLOAT_in_term661); 
				FLOAT92_tree = (CommonTree)adaptor.Create(FLOAT92);
				root_0 = (CommonTree)adaptor.BecomeRoot(FLOAT92_tree, root_0);

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// CK.g:104:4: STRING ^
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(104, 10);
				STRING93=(CommonToken)Match(input,STRING,Follow._STRING_in_term667); 
				STRING93_tree = (CommonTree)adaptor.Create(STRING93);
				root_0 = (CommonTree)adaptor.BecomeRoot(STRING93_tree, root_0);

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// CK.g:105:4: CHAR ^
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(105, 8);
				CHAR94=(CommonToken)Match(input,CHAR,Follow._CHAR_in_term673); 
				CHAR94_tree = (CommonTree)adaptor.Create(CHAR94);
				root_0 = (CommonTree)adaptor.BecomeRoot(CHAR94_tree, root_0);

				}
				break;
			case 14:
				DebugEnterAlt(14);
				// CK.g:106:4: TRUE ^
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(106, 8);
				TRUE95=(CommonToken)Match(input,TRUE,Follow._TRUE_in_term679); 
				TRUE95_tree = (CommonTree)adaptor.Create(TRUE95);
				root_0 = (CommonTree)adaptor.BecomeRoot(TRUE95_tree, root_0);

				}
				break;
			case 15:
				DebugEnterAlt(15);
				// CK.g:107:4: FALSE ^
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(107, 9);
				FALSE96=(CommonToken)Match(input,FALSE,Follow._FALSE_in_term685); 
				FALSE96_tree = (CommonTree)adaptor.Create(FALSE96);
				root_0 = (CommonTree)adaptor.BecomeRoot(FALSE96_tree, root_0);

				}
				break;
			case 16:
				DebugEnterAlt(16);
				// CK.g:108:4: VOID ^
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(108, 8);
				VOID97=(CommonToken)Match(input,VOID,Follow._VOID_in_term691); 
				VOID97_tree = (CommonTree)adaptor.Create(VOID97);
				root_0 = (CommonTree)adaptor.BecomeRoot(VOID97_tree, root_0);

				}
				break;

			}
			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("term", 15);
			LeaveRule("term", 15);
			LeaveRule_term();
		}
		DebugLocation(108, 8);
		} finally { DebugExitRule(GrammarFileName, "term"); }
		return retval;

	}
	// $ANTLR end "term"

	partial void EnterRule_invokeExprs();
	partial void LeaveRule_invokeExprs();
	// $ANTLR start "invokeExprs"
	// CK.g:110:1: invokeExprs : expr ( COMMA expr )* -> ^( InvokeExprs ( expr )+ ) ;
	[GrammarRule("invokeExprs")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> invokeExprs()
	{
		EnterRule_invokeExprs();
		EnterRule("invokeExprs", 16);
		TraceIn("invokeExprs", 16);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken COMMA99 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr98 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr100 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree COMMA99_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "invokeExprs");
		DebugLocation(110, 43);
		try
		{
			// CK.g:110:12: ( expr ( COMMA expr )* -> ^( InvokeExprs ( expr )+ ) )
			DebugEnterAlt(1);
			// CK.g:111:2: expr ( COMMA expr )*
			{
			DebugLocation(111, 2);
			PushFollow(Follow._expr_in_invokeExprs700);
			expr98=expr();
			PopFollow();

			stream_expr.Add(expr98.Tree);
			DebugLocation(111, 7);
			// CK.g:111:7: ( COMMA expr )*
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=2;
				try { DebugEnterDecision(22, false);
				int LA22_1 = input.LA(1);

				if ((LA22_1==COMMA))
				{
					alt22 = 1;
				}


				} finally { DebugExitDecision(22); }
				switch ( alt22 )
				{
				case 1:
					DebugEnterAlt(1);
					// CK.g:111:8: COMMA expr
					{
					DebugLocation(111, 8);
					COMMA99=(CommonToken)Match(input,COMMA,Follow._COMMA_in_invokeExprs703);  
					stream_COMMA.Add(COMMA99);

					DebugLocation(111, 14);
					PushFollow(Follow._expr_in_invokeExprs705);
					expr100=expr();
					PopFollow();

					stream_expr.Add(expr100.Tree);

					}
					break;

				default:
					goto loop22;
				}
			}

			loop22:
				;

			} finally { DebugExitSubRule(22); }



			{
			// AST REWRITE
			// elements: expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 111:21: -> ^( InvokeExprs ( expr )+ )
			{
				DebugLocation(111, 24);
				// CK.g:111:24: ^( InvokeExprs ( expr )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(111, 26);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(InvokeExprs, "InvokeExprs"), root_1);

				DebugLocation(111, 38);
				if (!(stream_expr.HasNext))
                {
                    DebugRecognitionException(new RewriteEarlyExitException());
					//throw new RewriteEarlyExitException();
				}
				while ( stream_expr.HasNext )
				{
					DebugLocation(111, 38);
					adaptor.AddChild(root_1, stream_expr.NextTree());

				}
				stream_expr.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("invokeExprs", 16);
			LeaveRule("invokeExprs", 16);
			LeaveRule_invokeExprs();
		}
		DebugLocation(111, 43);
		} finally { DebugExitRule(GrammarFileName, "invokeExprs"); }
		return retval;

	}
	// $ANTLR end "invokeExprs"

	partial void EnterRule_varExprs();
	partial void LeaveRule_varExprs();
	// $ANTLR start "varExprs"
	// CK.g:113:1: varExprs : localOrFieldInit ( COMMA localOrFieldInit )* -> ^( VarExprs ( localOrFieldInit )+ ) ;
	[GrammarRule("varExprs")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> varExprs()
	{
		EnterRule_varExprs();
		EnterRule("varExprs", 17);
		TraceIn("varExprs", 17);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken COMMA102 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> localOrFieldInit101 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> localOrFieldInit103 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree COMMA102_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_localOrFieldInit=new RewriteRuleSubtreeStream(adaptor,"rule localOrFieldInit");
		try { DebugEnterRule(GrammarFileName, "varExprs");
		DebugLocation(113, 76);
		try
		{
			// CK.g:113:9: ( localOrFieldInit ( COMMA localOrFieldInit )* -> ^( VarExprs ( localOrFieldInit )+ ) )
			DebugEnterAlt(1);
			// CK.g:114:2: localOrFieldInit ( COMMA localOrFieldInit )*
			{
			DebugLocation(114, 2);
			PushFollow(Follow._localOrFieldInit_in_varExprs726);
			localOrFieldInit101=localOrFieldInit();
			PopFollow();

			stream_localOrFieldInit.Add(localOrFieldInit101.Tree);
			DebugLocation(114, 19);
			// CK.g:114:19: ( COMMA localOrFieldInit )*
			try { DebugEnterSubRule(23);
			while (true)
			{
				int alt23=2;
				try { DebugEnterDecision(23, false);
				int LA23_1 = input.LA(1);

				if ((LA23_1==COMMA))
				{
					alt23 = 1;
				}


				} finally { DebugExitDecision(23); }
				switch ( alt23 )
				{
				case 1:
					DebugEnterAlt(1);
					// CK.g:114:20: COMMA localOrFieldInit
					{
					DebugLocation(114, 20);
					COMMA102=(CommonToken)Match(input,COMMA,Follow._COMMA_in_varExprs729);  
					stream_COMMA.Add(COMMA102);

					DebugLocation(114, 26);
					PushFollow(Follow._localOrFieldInit_in_varExprs731);
					localOrFieldInit103=localOrFieldInit();
					PopFollow();

					stream_localOrFieldInit.Add(localOrFieldInit103.Tree);

					}
					break;

				default:
					goto loop23;
				}
			}

			loop23:
				;

			} finally { DebugExitSubRule(23); }



			{
			// AST REWRITE
			// elements: localOrFieldInit
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 114:45: -> ^( VarExprs ( localOrFieldInit )+ )
			{
				DebugLocation(114, 48);
				// CK.g:114:48: ^( VarExprs ( localOrFieldInit )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(114, 50);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(VarExprs, "VarExprs"), root_1);

				DebugLocation(114, 59);
				if (!(stream_localOrFieldInit.HasNext))
                {
                    DebugRecognitionException(new RewriteEarlyExitException());
					//throw new RewriteEarlyExitException();
				}
				while ( stream_localOrFieldInit.HasNext )
				{
					DebugLocation(114, 59);
					adaptor.AddChild(root_1, stream_localOrFieldInit.NextTree());

				}
				stream_localOrFieldInit.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("varExprs", 17);
			LeaveRule("varExprs", 17);
			LeaveRule_varExprs();
		}
		DebugLocation(114, 76);
		} finally { DebugExitRule(GrammarFileName, "varExprs"); }
		return retval;

	}
	// $ANTLR end "varExprs"

	partial void EnterRule_localOrFieldInit();
	partial void LeaveRule_localOrFieldInit();
	// $ANTLR start "localOrFieldInit"
	// CK.g:116:1: localOrFieldInit : ID COLON typeName ( ASSIGN expr )? -> ^( LocalOrFieldInit ID typeName ( expr )? ) ;
	[GrammarRule("localOrFieldInit")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> localOrFieldInit()
	{
		EnterRule_localOrFieldInit();
		EnterRule("localOrFieldInit", 18);
		TraceIn("localOrFieldInit", 18);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken ID104 = default(CommonToken);
		CommonToken COLON105 = default(CommonToken);
		CommonToken ASSIGN107 = default(CommonToken);
		AstParserRuleReturnScope<CommonTree, CommonToken> typeName106 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);
		AstParserRuleReturnScope<CommonTree, CommonToken> expr108 = default(AstParserRuleReturnScope<CommonTree, CommonToken>);

		CommonTree ID104_tree = default(CommonTree);
		CommonTree COLON105_tree = default(CommonTree);
		CommonTree ASSIGN107_tree = default(CommonTree);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_typeName=new RewriteRuleSubtreeStream(adaptor,"rule typeName");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "localOrFieldInit");
		DebugLocation(116, 74);
		try
		{
			// CK.g:116:17: ( ID COLON typeName ( ASSIGN expr )? -> ^( LocalOrFieldInit ID typeName ( expr )? ) )
			DebugEnterAlt(1);
			// CK.g:117:2: ID COLON typeName ( ASSIGN expr )?
			{
			DebugLocation(117, 2);
			ID104=(CommonToken)Match(input,ID,Follow._ID_in_localOrFieldInit751);  
			stream_ID.Add(ID104);

			DebugLocation(117, 5);
			COLON105=(CommonToken)Match(input,COLON,Follow._COLON_in_localOrFieldInit753);  
			stream_COLON.Add(COLON105);

			DebugLocation(117, 11);
			PushFollow(Follow._typeName_in_localOrFieldInit755);
			typeName106=typeName();
			PopFollow();

			stream_typeName.Add(typeName106.Tree);
			DebugLocation(117, 20);
			// CK.g:117:20: ( ASSIGN expr )?
			int alt24=2;
			try { DebugEnterSubRule(24);
			try { DebugEnterDecision(24, false);
			int LA24_1 = input.LA(1);

			if ((LA24_1==ASSIGN))
			{
				alt24 = 1;
			}
			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// CK.g:117:21: ASSIGN expr
				{
				DebugLocation(117, 21);
				ASSIGN107=(CommonToken)Match(input,ASSIGN,Follow._ASSIGN_in_localOrFieldInit758);  
				stream_ASSIGN.Add(ASSIGN107);

				DebugLocation(117, 28);
				PushFollow(Follow._expr_in_localOrFieldInit760);
				expr108=expr();
				PopFollow();

				stream_expr.Add(expr108.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(24); }



			{
			// AST REWRITE
			// elements: ID, typeName, expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 117:35: -> ^( LocalOrFieldInit ID typeName ( expr )? )
			{
				DebugLocation(117, 38);
				// CK.g:117:38: ^( LocalOrFieldInit ID typeName ( expr )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(117, 40);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(LocalOrFieldInit, "LocalOrFieldInit"), root_1);

				DebugLocation(117, 57);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(117, 60);
				adaptor.AddChild(root_1, stream_typeName.NextTree());
				DebugLocation(117, 69);
				// CK.g:117:69: ( expr )?
				if (stream_expr.HasNext)
				{
					DebugLocation(117, 69);
					adaptor.AddChild(root_1, stream_expr.NextTree());

				}
				stream_expr.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("localOrFieldInit", 18);
			LeaveRule("localOrFieldInit", 18);
			LeaveRule_localOrFieldInit();
		}
		DebugLocation(117, 74);
		} finally { DebugExitRule(GrammarFileName, "localOrFieldInit"); }
		return retval;

	}
	// $ANTLR end "localOrFieldInit"

	partial void EnterRule_typeName();
	partial void LeaveRule_typeName();
	// $ANTLR start "typeName"
	// CK.g:119:1: typeName : ( IntTypeName | FloatTypeName | BoolTypeName | StringTypeName | CharTypeName | ObjectTypeName | ID );
	[GrammarRule("typeName")]
	private AstParserRuleReturnScope<CommonTree, CommonToken> typeName()
	{
		EnterRule_typeName();
		EnterRule("typeName", 19);
		TraceIn("typeName", 19);
		AstParserRuleReturnScope<CommonTree, CommonToken> retval = new AstParserRuleReturnScope<CommonTree, CommonToken>();
		retval.Start = (CommonToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		CommonToken set109 = default(CommonToken);

		CommonTree set109_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "typeName");
		DebugLocation(119, 5);
		try
		{
			// CK.g:120:2: ( IntTypeName | FloatTypeName | BoolTypeName | StringTypeName | CharTypeName | ObjectTypeName | ID )
			DebugEnterAlt(1);
			// CK.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(120, 2);

			set109=(CommonToken)input.LT(1);
			if (input.LA(1)==BoolTypeName||input.LA(1)==CharTypeName||input.LA(1)==FloatTypeName||input.LA(1)==ID||input.LA(1)==IntTypeName||input.LA(1)==ObjectTypeName||input.LA(1)==StringTypeName)
			{
				input.Consume();
				adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set109));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				//throw mse;
			}


			}

			retval.Stop = (CommonToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}

		    catch (RecognitionException ex) {
		    	DebugRecognitionException(ex);
		    }

		finally
		{
			TraceOut("typeName", 19);
			LeaveRule("typeName", 19);
			LeaveRule_typeName();
		}
		DebugLocation(126, 5);
		} finally { DebugExitRule(GrammarFileName, "typeName"); }
		return retval;

	}
	// $ANTLR end "typeName"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _classDef_in_program146 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _SEMI_in_program148 = new BitSet(new ulong[]{0x82UL});
		public static readonly BitSet _CLASS_in_classDef169 = new BitSet(new ulong[]{0x810002108000820UL});
		public static readonly BitSet _typeName_in_classDef171 = new BitSet(new ulong[]{0x8000000100UL});
		public static readonly BitSet _COLON_in_classDef174 = new BitSet(new ulong[]{0x810002108000820UL});
		public static readonly BitSet _typeName_in_classDef176 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _LCURLY_in_classDef180 = new BitSet(new ulong[]{0x40000100000000UL});
		public static readonly BitSet _featureList_in_classDef182 = new BitSet(new ulong[]{0x40000000000000UL});
		public static readonly BitSet _RCURLY_in_classDef184 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _feature_in_featureList210 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _SEMI_in_featureList212 = new BitSet(new ulong[]{0x100000002UL});
		public static readonly BitSet _ID_in_feature235 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _LPAREN_in_feature237 = new BitSet(new ulong[]{0x100000100000000UL});
		public static readonly BitSet _formalList_in_feature240 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _RPAREN_in_feature244 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _COLON_in_feature246 = new BitSet(new ulong[]{0x810002108000820UL});
		public static readonly BitSet _typeName_in_feature248 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _LCURLY_in_feature250 = new BitSet(new ulong[]{0xA48E088F03000040UL,0x5UL});
		public static readonly BitSet _expr_in_feature252 = new BitSet(new ulong[]{0x40000000000000UL});
		public static readonly BitSet _RCURLY_in_feature254 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _localOrFieldInit_in_feature281 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _formal_in_formalList290 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _COMMA_in_formalList293 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _formal_in_formalList295 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _ID_in_formal313 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _COLON_in_formal315 = new BitSet(new ulong[]{0x810002108000820UL});
		public static readonly BitSet _typeName_in_formal318 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_expr327 = new BitSet(new ulong[]{0x10UL});
		public static readonly BitSet _ASSIGN_in_expr329 = new BitSet(new ulong[]{0xA48E088F03000040UL,0x5UL});
		public static readonly BitSet _not_in_expr334 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_in_not345 = new BitSet(new ulong[]{0xA48E088F03000040UL,0x5UL});
		public static readonly BitSet _relation_in_not350 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _addition_in_relation359 = new BitSet(new ulong[]{0x1100C0100002UL});
		public static readonly BitSet _LE_in_relation363 = new BitSet(new ulong[]{0xA486088F03000040UL,0x5UL});
		public static readonly BitSet _LT_in_relation368 = new BitSet(new ulong[]{0xA486088F03000040UL,0x5UL});
		public static readonly BitSet _GE_in_relation373 = new BitSet(new ulong[]{0xA486088F03000040UL,0x5UL});
		public static readonly BitSet _GT_in_relation378 = new BitSet(new ulong[]{0xA486088F03000040UL,0x5UL});
		public static readonly BitSet _EQUAL_in_relation383 = new BitSet(new ulong[]{0xA486088F03000040UL,0x5UL});
		public static readonly BitSet _addition_in_relation387 = new BitSet(new ulong[]{0x1100C0100002UL});
		public static readonly BitSet _multiplication_in_addition398 = new BitSet(new ulong[]{0x20400000000002UL});
		public static readonly BitSet _PLUS_in_addition402 = new BitSet(new ulong[]{0xA486088F03000040UL,0x5UL});
		public static readonly BitSet _MINUS_in_addition407 = new BitSet(new ulong[]{0xA486088F03000040UL,0x5UL});
		public static readonly BitSet _multiplication_in_addition411 = new BitSet(new ulong[]{0x20400000000002UL});
		public static readonly BitSet _isvoid_in_multiplication421 = new BitSet(new ulong[]{0x800000008002UL});
		public static readonly BitSet _MULT_in_multiplication425 = new BitSet(new ulong[]{0xA486088F03000040UL,0x5UL});
		public static readonly BitSet _DIV_in_multiplication430 = new BitSet(new ulong[]{0xA486088F03000040UL,0x5UL});
		public static readonly BitSet _isvoid_in_multiplication434 = new BitSet(new ulong[]{0x800000008002UL});
		public static readonly BitSet _ISVOID_in_isvoid445 = new BitSet(new ulong[]{0xA486088F03000040UL,0x5UL});
		public static readonly BitSet _neg_in_isvoid450 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEG_in_neg459 = new BitSet(new ulong[]{0xA486088703000040UL,0x5UL});
		public static readonly BitSet _dot_in_neg464 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _term_in_dot476 = new BitSet(new ulong[]{0x10002UL});
		public static readonly BitSet _DOT_in_dot479 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _ID_in_dot481 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _LPAREN_in_dot483 = new BitSet(new ulong[]{0xA58E088F03000040UL,0x5UL});
		public static readonly BitSet _invokeExprs_in_dot485 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _RPAREN_in_dot488 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_term516 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _LPAREN_in_term518 = new BitSet(new ulong[]{0xA58E088F03000040UL,0x5UL});
		public static readonly BitSet _invokeExprs_in_term520 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _RPAREN_in_term523 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IF_in_term539 = new BitSet(new ulong[]{0xA48E088F03000040UL,0x5UL});
		public static readonly BitSet _expr_in_term542 = new BitSet(new ulong[]{0x1000000000000000UL});
		public static readonly BitSet _THEN_in_term544 = new BitSet(new ulong[]{0xA48E088F03000040UL,0x5UL});
		public static readonly BitSet _expr_in_term547 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _ELSE_in_term549 = new BitSet(new ulong[]{0xA48E088F03000040UL,0x5UL});
		public static readonly BitSet _expr_in_term552 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _ENDIF_in_term554 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILE_in_term560 = new BitSet(new ulong[]{0xA48E088F03000040UL,0x5UL});
		public static readonly BitSet _expr_in_term563 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _LOOP_in_term565 = new BitSet(new ulong[]{0xA48E088F03000040UL,0x5UL});
		public static readonly BitSet _expr_in_term568 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _ENDLOOP_in_term570 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LCURLY_in_term576 = new BitSet(new ulong[]{0xA48E088F03000040UL,0x5UL});
		public static readonly BitSet _expr_in_term579 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _SEMI_in_term581 = new BitSet(new ulong[]{0xA4CE088F03000040UL,0x5UL});
		public static readonly BitSet _RCURLY_in_term585 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VAR_in_term599 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _varExprs_in_term602 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _SEMI_in_term604 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEW_in_term610 = new BitSet(new ulong[]{0x810002108000820UL});
		public static readonly BitSet _typeName_in_term613 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _SEMI_in_term615 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RETURN_in_term621 = new BitSet(new ulong[]{0xA48E088F03000040UL,0x5UL});
		public static readonly BitSet _expr_in_term624 = new BitSet(new ulong[]{0x200000000000000UL});
		public static readonly BitSet _SEMI_in_term626 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_term632 = new BitSet(new ulong[]{0xA48E088F03000040UL,0x5UL});
		public static readonly BitSet _expr_in_term634 = new BitSet(new ulong[]{0x100000000000000UL});
		public static readonly BitSet _RPAREN_in_term636 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_term649 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INTEGER_in_term655 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FLOAT_in_term661 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_in_term667 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CHAR_in_term673 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TRUE_in_term679 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FALSE_in_term685 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VOID_in_term691 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expr_in_invokeExprs700 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _COMMA_in_invokeExprs703 = new BitSet(new ulong[]{0xA48E088F03000040UL,0x5UL});
		public static readonly BitSet _expr_in_invokeExprs705 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _localOrFieldInit_in_varExprs726 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _COMMA_in_varExprs729 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _localOrFieldInit_in_varExprs731 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _ID_in_localOrFieldInit751 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _COLON_in_localOrFieldInit753 = new BitSet(new ulong[]{0x810002108000820UL});
		public static readonly BitSet _typeName_in_localOrFieldInit755 = new BitSet(new ulong[]{0x12UL});
		public static readonly BitSet _ASSIGN_in_localOrFieldInit758 = new BitSet(new ulong[]{0xA48E088F03000040UL,0x5UL});
		public static readonly BitSet _expr_in_localOrFieldInit760 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace CKCompiler.Analyzers
